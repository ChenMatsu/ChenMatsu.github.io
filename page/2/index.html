<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chenmatsu.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Nothing more than curiosity">
<meta property="og:type" content="website">
<meta property="og:title" content="Matsu">
<meta property="og:url" content="https://chenmatsu.github.io/page/2/index.html">
<meta property="og:site_name" content="Matsu">
<meta property="og:description" content="Nothing more than curiosity">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Matsu Chen">
<meta property="article:tag" content="Matsu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chenmatsu.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Matsu</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Matsu</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Nothing more than curiosity</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜尋" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Matsu Chen</p>
  <div class="site-description" itemprop="description">Nothing more than curiosity</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/31/React%E7%B3%BB%E5%88%97-%E7%8E%A9%E8%BD%89Typescript%E5%BE%85%E8%BE%A6%E6%B8%85%E5%96%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/31/React%E7%B3%BB%E5%88%97-%E7%8E%A9%E8%BD%89Typescript%E5%BE%85%E8%BE%A6%E6%B8%85%E5%96%AE/" class="post-title-link" itemprop="url">React系列-玩轉Typescript待辦清單(上)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-31 10:54:34" itemprop="dateCreated datePublished" datetime="2021-05-31T10:54:34+08:00">2021-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Typescript/" itemprop="url" rel="index"><span itemprop="name">Typescript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="玩轉Typescript"><a href="#玩轉Typescript" class="headerlink" title="玩轉Typescript"></a>玩轉Typescript</h3><blockquote>
<p><em>Yesterday is gone. Tomorrow has not yet come. We have only today. Let us begin.</em><br><em>― Mother Theresa</em></p>
</blockquote>
<p>五月的最後一天，明天開始將掀開六月的篇章，未來還有很多挑戰，但今天才是最重要的。</p>
<p>今天想透過React使用Typescript去建立一個簡單的Todolist清單，在四月初其實有使用過React實作過，但當時的自己對於React可以說是完全不了解，很多東西都是到處參考，相當雜亂。本篇將透過介紹Typescript開始玩轉待辦清單(Todolist)。</p>
<p>-預備知識-</p>
<ul>
<li>useRef、useContext Hooks使用方式</li>
</ul>
<hr>
<ul>
<li>Typescript待辦清單<ul>
<li>介紹Typescript</li>
<li>實作Todolist</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Typescript待辦清單"><a href="#Typescript待辦清單" class="headerlink" title="Typescript待辦清單"></a>Typescript待辦清單</h4><p>開始實作前需要先理解一下Typescript是什麼，乍看下，跟Javascript很相似。我們的直覺並沒有錯，Typescript確實就是Javascript的超集合，換句話說，有點像是C++與C的關係，C++整體而言多出OOP的概念。Typescript則是比Javascript多出更嚴謹、明確的類別定義。</p>
<h5 id="介紹Typescript"><a href="#介紹Typescript" class="headerlink" title="介紹Typescript"></a>介紹Typescript</h5><p>個人而言，Typescript給我的感覺很像是C，不知道為什麼在寫Typescript的時候，腦中一直浮現C的感覺，說起來相當微妙，不過卻又不盡相同。我們看一下範例:</p>
<p><code>let num: number = 2021;</code></p>
<p>唯一不同於JS的地方在於變數名稱後方多了冒號:，冒號後方再接上變數型態。Typescript的名稱很明顯告訴我們，它的主要概念就在於定義Type，嚴謹的定義，可以免於許多不明確的程式碼。</p>
<p>變數可以定義，函數沒有道理不能定義:</p>
<p><code>function add(a: number, b: number): number| string &#123;   return a + b; &#125;</code></p>
<p>參數的定義是number外，回傳值則是設定為number或string，不覺得很像是C語言嗎? 好吧，可能我深受C的荼毒有點深。特別去注意到，若我們沒有給參數任何型態，一般來說，IDE都會跳出警訊，如下:</p>
<p><code>function printEverything(value) &#123;     console.log(value); &#125;</code><br>↓<br><code>function printEverything(value: any) &#123;     console.log(value); &#125;</code></p>
<p>此時就會跳出警訊，解決方式就是在value後方加上類別，若不想指定特定類別，至少也得加上<strong>any</strong>，TS才能理解我們並不想指定特定類別，才不至於產生錯誤。</p>
<p>重複定義其實會有點惱人，因為若需要更改物件的某些定義，就必須要逐一修改，因此TS有個更方便的定義類別方式<strong>type</strong>。</p>
<figure class="highlight plaintext"><figcaption><span>Person</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  address: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let Matsu = Person;</span><br><span class="line">let People = Person[];</span><br></pre></td></tr></table></figure>

<p>往後若需要修改這個類別，僅需要修改Person，使用方式則和先前提到的number, string相似，若要使用類別作為陣列，僅需要在後方加上[]即可。</p>
<p>最後關於Typescript最特別的大概是所謂的<strong>通用型類別</strong>(Generic Type)，實際看一下例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function insertValue&lt;Type&gt;(array: Type[], value: Type)&#123;</span><br><span class="line">  const newArray = [value, ...array];</span><br><span class="line">  return newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const nums = [1, 2, 3];</span><br><span class="line">const newNums = insertValue(nums, 4);</span><br><span class="line"></span><br><span class="line">const strs = [&#x27;Matsu&#x27;, &#x27;Chen&#x27;];</span><br><span class="line">const newStrs = insertValue(strs, &#x27;Taichung&#x27;);</span><br><span class="line">// ↓</span><br><span class="line">// const newStrs = insertValue&lt;String&gt;(strs, &#x27;Taichung&#x27;);</span><br></pre></td></tr></table></figure>

<p>最特別的地方在於<Type>這段，這就是所謂的Generic Type，在此處會根據array和value的類別，去決定函數回傳的類別是數值或是字串，當然我們也可以明確地定義它們的類別，甚至是自行定義Generic Interfaces，不過超出本篇內容就先不提。</p>
<h5 id="實作Todolist"><a href="#實作Todolist" class="headerlink" title="實作Todolist"></a>實作Todolist</h5><p>首先要在React專案中使用Typescript，必須匯入相關的lib，幸運的是create-react-app同樣有指令可以幫助我們一塊兒處理這部分的問題:<br><code>npx create-react-app --template typescript</code><br>執行上述的程式碼後就可以正式使用Typescript於React當中。</p>
<p>首先建立Todolist項目的類別型態，單純用於<strong>明確定義</strong>資料的型別。因此在src資料夾下建立models的資料夾後在其中建立todo.ts的檔案，基本上，一個專案會有各種models去定義各自使用的類別，不過我們目前只需要todo項目的資料型別即可:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;todo.ts&quot;</span><br><span class="line">class Todo &#123;</span><br><span class="line">  // 定義建構子(Contructor)使用到的變數類型</span><br><span class="line">  id: string;</span><br><span class="line">  name: string;</span><br><span class="line"></span><br><span class="line">  constructor(todoName: string) &#123;</span><br><span class="line">    // 傳遞進來的值作為名稱指派給新實體 -&gt; 新增新的項目時傳遞</span><br><span class="line">    this.name = todoName;</span><br><span class="line">    // 轉換日期作為辨識的id值</span><br><span class="line">    this.id = new Date().toISOString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Todo;</span><br></pre></td></tr></table></figure>

<p>完成建立後，TS與JS間的差別在於TS必須先行定義變數的類別，另外todoName乍看下還不太懂用意，它主要會在後續新增項目的函數內使用到。完成最重要的類別定義後，接下來我們使用ContextAPI管理使用的資料，而不是透過props去處理資料，相關優缺點可以參考先前的幾篇文章。</p>
<p>同樣地，src資料夾下新建立資料夾store存放Context，在store中建立<strong>todos-context.tsx</strong>的檔案，注意到先前是jsx這裡自然而然就要改寫成tsx才能夠編譯TS相關的程式碼，往後就不再贅述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;todos-context.tsx&quot;</span><br><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import Todo from &#x27;../models/todo.ts&#x27;;</span><br><span class="line"></span><br><span class="line">// 定義通用類型 </span><br><span class="line">type TodoContextObj &#123;</span><br><span class="line">  todos: Todo[];</span><br><span class="line">  addTodo: (name: string) =&gt; void;</span><br><span class="line">  deleteTodo: (id: string) =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 建立Context API</span><br><span class="line">export const TodoContext = React.createContext&lt;TodoContextObj&gt;(&#123;</span><br><span class="line">  todos: [],</span><br><span class="line">  addTodo: () =&gt; &#123;&#125;,</span><br><span class="line">  deleteTodo: (id: string) =&gt; &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// React.FC告訴TS這是一個React函數組件，需要有props可以傳遞</span><br><span class="line">const TodoContextProvider: React.FC = (props) =&gt; &#123;</span><br><span class="line">  // 剛開始初始化時為空陣列，後續更新過後則為Todo類別</span><br><span class="line">  const [todos, setTodos] = useState&lt;Todo[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  // 新增項目</span><br><span class="line">  const addTodoHandler = (todoName: string) =&gt; &#123;</span><br><span class="line">    const newTodo = new Todo(todoName);</span><br><span class="line"></span><br><span class="line">    // 透過先前的陣列狀況去更新陣列</span><br><span class="line">    setTodos((prevTodos) =&gt; &#123;</span><br><span class="line">      return prevTodos.concat(newTodo);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 刪除項目</span><br><span class="line">  const deleteTodoHandler = (todoId: string) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    setTodos((prevTodos) =&gt; &#123;</span><br><span class="line">      // 透過Array內建函數filter過濾掉id相符的項目</span><br><span class="line">      return prevTodos.filter( todo =&gt; todo.id !== todoId);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const todoContextValue: TodosContextObj = &#123;</span><br><span class="line">    todos: todos,</span><br><span class="line">    addtodo: addTodoHandler,</span><br><span class="line">    deleteTodo: deleteTodoHandler</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 傳遞狀態</span><br><span class="line">  return (</span><br><span class="line">    &lt;TodoContext.Provider value=&#123;todoContextValue&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/TodoContext.Prodiver&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default TodoContextProvider;</span><br></pre></td></tr></table></figure>
<p>使用TS最大優點在於嚴謹明確，但相對的也必須負擔較多的責任，透過使用Generic的方式，將自定義類別<strong>TodosContextObj</strong>分別傳入contextAPI與todosContextObj也是為了解決這部份的問題。相對於為各自的props重複撰寫，我想透過contextAPI去處理已經省略相當多重複的程式區塊。</p>
<p>到目前為止，我們已經完成最重要的兩步驟，定義類別與ContextAPI，處理完這兩個檔案後，最後僅需要將資料運用在組件上就算正式完成。</p>
<p><img src="https://i.imgur.com/9iAiaPc.jpg" alt="pic"></p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>這篇文章主要講解Typescript的基礎及結合React使用的方式，透過搭配React Hooks展現出更強大的應用能力。希望能夠將內容講解得更詳盡，因此會分上下兩篇文章，若有任何問題歡迎私訊。 </p>
<p>我個人挺喜歡Typescript給我的感覺，使用上雖然有比較多地方需要注意，卻給我一種不一樣的美，程式碼變得更加純淨的感覺。我想這就是學習的路上有趣的地方，Typescript明明要求得更多卻更簡潔有力，這不是一件很厲害的事情嗎? 看起來限制更多卻更能夠發揮自己的想法，雖然我理解的還很少，但我覺得Typescript很值得去學習。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/28/React%E7%B3%BB%E5%88%97-JEST%E6%B8%AC%E8%A9%A6%E6%A6%82%E5%BF%B5%E8%88%87%E4%BD%BF%E7%94%A8-%E7%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/28/React%E7%B3%BB%E5%88%97-JEST%E6%B8%AC%E8%A9%A6%E6%A6%82%E5%BF%B5%E8%88%87%E4%BD%BF%E7%94%A8-%E7%BA%8C/" class="post-title-link" itemprop="url">React系列-JEST測試概念與使用(續)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-28 16:26:56" itemprop="dateCreated datePublished" datetime="2021-05-28T16:26:56+08:00">2021-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Test/" itemprop="url" rel="index"><span itemprop="name">Test</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="React-with-JEST"><a href="#React-with-JEST" class="headerlink" title="React with JEST"></a>React with JEST</h3><blockquote>
<p><em>You cannot change what you are, only what you do.</em><br><em>― Philip Pullman, The Golden Compass</em></p>
</blockquote>
<ul>
<li>實際測試</li>
<li>結語</li>
</ul>
<p>今天延續上篇JEST測驗概念與使用的內容，若還沒看的朋友們，可以點開下方連結讀過再來看本篇。</p>
<p><strong>React系列-JEST測試概念與使用: <a target="_blank" rel="noopener" href="https://tinyurl.com/yh5puf3t">https://tinyurl.com/yh5puf3t</a></strong></p>
<p>前幾天稍微聊過關於測試的類別與JEST的使用，最後展示基本範例的測試過程。在本篇我們將來討論其他方面的測試。話不多說，現在就來進入正題。</p>
<hr>
<h4 id="實際測試"><a href="#實際測試" class="headerlink" title="實際測試"></a>實際測試</h4><p>首先建立新的檔案叫做<strong>GoodBye.js</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// In GoodBye.js</span><br><span class="line">const GoodBye = props =&gt; &#123;</span><br><span class="line">  return &lt;p&gt;&#123;props.children&#125;&lt;/p&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default GoodBye;</span><br></pre></td></tr></table></figure>
<p>建立這個檔案用途是能夠在<strong>Greeting.test.js</strong>當中，一同測試GoodBye組件，去試著了解整合測試的概念。同時，我們在Greeting組件匯入GoodBye並且將檔案修改一下，相信大家對於props.children不會太陌生，用一句話來說的話，就是打包內容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;Greeting.js&quot;</span><br><span class="line">import GoodBye from &#x27;./GoodBye&#x27;;</span><br><span class="line"></span><br><span class="line">const Greeting = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">      &lt;GoodBye&gt;It is good to see you.&lt;/GoodBye&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Greeting;</span><br></pre></td></tr></table></figure>
<p>接著修改測試檔案的內容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;Greeting.test.js&quot;</span><br><span class="line">describe(&#x27;&lt;Greeting /&gt;&#x27;, () =&gt; &#123;</span><br><span class="line">  test(&#x27;Render Hello World as a text&#x27;, () =&gt; &#123;</span><br><span class="line">    render(&lt;Greeting /&gt;);</span><br><span class="line"></span><br><span class="line">    const findText = screen.getByText(&#x27;Hello World&#x27;, &#123; exact: false &#125;);</span><br><span class="line">    expect(findText).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  test(&#x27;GoodBye in Greeting&#x27;, () =&gt; &#123;</span><br><span class="line">    render(&lt;Greeting /&gt;);</span><br><span class="line">    </span><br><span class="line">    const findGoodBye = screen.getByText(&#x27;It is good to see you.&#x27;, &#123; exact: true&#125;);</span><br><span class="line">    expect(findGoodBye).toBeInTheDocument();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>特別的是<strong>describe</strong>函數主要用來告知Test要測試的是一個組合(Suite)，每一個describe可以有數個test，使用方式和test函數相似。延續上篇文章的測試後，出現下方結果。</p>
<p><img src="https://i.imgur.com/07nGgkM.jpg" alt="test"></p>
<p>緊接著來討論關於事件的測試方式，將Greeting組件修改，增加一個狀態管理文字是否顯示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">import GoodBye from &#x27;./GoodBye&#x27;;</span><br><span class="line"></span><br><span class="line">const Greeting = () =&gt; &#123;</span><br><span class="line">  const [text, setText] = useState(false);</span><br><span class="line"></span><br><span class="line">  const changeText = () =&gt; &#123;</span><br><span class="line">      setText(true);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">      &#123;!text &amp;&amp; &lt;GoodBye&gt;It is good to see you.&lt;/GoodBye&gt;&#125;</span><br><span class="line">      &#123;text &amp;&amp; &lt;GoodBye&gt;Not good to see you.&lt;/GoodBye&gt;&#125;</span><br><span class="line">      &lt;button onClick=&#123;changeText&#125;&gt;Change Text!&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Greeting;</span><br></pre></td></tr></table></figure>
<p>因為測試事件需要模擬使用者點擊的行為，必須先引入<strong>userEvent</strong>物件進行模擬。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;Greeting.test.js&quot;</span><br><span class="line">import userEvent from &#x27;@test-library/user-event</span><br><span class="line"></span><br><span class="line">describe(&#x27;&lt;Greeting /&gt;&#x27;, () =&gt; &#123;</span><br><span class="line">  ...同上述測試碼...</span><br><span class="line"></span><br><span class="line">  test(&#x27;Check original text is invisible&#x27;, () =&gt; &#123;</span><br><span class="line">      render(&lt;Greeting /&gt;);</span><br><span class="line"></span><br><span class="line">      const button = screen.getByRole(&#x27;button&#x27;);</span><br><span class="line">      userEvent.click(button);</span><br><span class="line"></span><br><span class="line">      const originalText = screen.queryByText(&#x27;It is good to see you.&#x27;);</span><br><span class="line">      expect(originalText).toBeNull();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);     </span><br></pre></td></tr></table></figure>
<p>新增模擬按鈕的測試後，此處只有一個按鈕，直接透過getByRole去找到唯一的一個按鈕。實際上選擇方式和JS處理DOM的概念一樣，接著透過userEvent物件的方式click去模擬按鈕的行為，最後搜尋是否有原先的文字。注意到queryByText作用和getByText一樣，差別在於<strong>query若找到目標會回傳相符的節點，若沒有找到目標則會回傳null</strong>。現在執行測試就會看到三個測試通過囉!</p>
<p><img src="https://i.imgur.com/CdV1WJR.jpg" alt="test2"></p>
<p>最後我們來看看本日的最後一個測試，主要針對fetch API和資料庫互動的測試。我們來仔細思考一下若測試時也真的與資料庫互動，會產生哪些問題? 以下是可能發生的問題:</p>
<ul>
<li>資料庫流量擁擠</li>
<li>影響資料庫資料</li>
<li>測試成本暴增</li>
</ul>
<p>當我們主要想測試是否可以連線成功時，其實是完全不需要真的跟資料庫有後續的互動，即便是真的需要驗證資料庫是否可以成功運作，我想也會有一個模擬的資料庫，而不是與實際使用的資料庫溝通。我們先新增一個新的組件Async。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;Async.js&quot;</span><br><span class="line">import &#123; useEffect, useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const Async = () =&gt; &#123;</span><br><span class="line">  const [posts, setPosts] = useState([]);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 網路上公開測試用API</span><br><span class="line">    fetch(&#x27;https://jsonplaceholder.typicode.com/posts&#x27;)</span><br><span class="line">      .then((response) =&gt; response.json())</span><br><span class="line">      .then((data) =&gt; &#123;</span><br><span class="line">        setPosts(data);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;posts.map((post) =&gt; (</span><br><span class="line">          &lt;li key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Async;</span><br></pre></td></tr></table></figure>
<p>使用fetch API需要處理非同步的問題，因為從資料庫傳來的資料需要時間傳遞。在Async組件當中使用到useEffect和useState兩個Hooks，用途可以參見先前的文章。另外建立Async.test.js的檔案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; render, screen &#125; from &#x27;@testing-library/react&#x27;;</span><br><span class="line"></span><br><span class="line">import Asnyc from &#x27;./Async&#x27;;</span><br><span class="line"></span><br><span class="line">describe(&#x27;Asynchronous API Testing&#x27;, () =&gt; &#123;</span><br><span class="line">  test(&#x27;Check request successes or not&#x27;, async () =&gt; &#123;</span><br><span class="line">    // 建立Mock(Spy)</span><br><span class="line">    window.fetch = jest.fn();</span><br><span class="line">    // 覆寫fecth API的動作，連線後回傳資料</span><br><span class="line">    window.fetch.mockResolvedValueOnce(&#123;</span><br><span class="line">      json: async () =&gt; [&#123; id: &#x27;p1&#x27;, title: &#x27;First Post&#x27; &#125;],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    render(&lt;Asnyc /&gt;);</span><br><span class="line"></span><br><span class="line">    // 等待fetch動作完成後檢查是否有listitem陣列</span><br><span class="line">    const listItem = await screen.findAllByRole(&#x27;listitem&#x27;);</span><br><span class="line">    expect(listItem).not.toHaveLength(0);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>處理非同步的問題需要覆寫fetch API的方法，這裡必須呼叫<strong>window.fetch</strong>才能夠正確覆寫，單純只呼叫fetch API會直接使用這個函數而無法覆寫。接著透過<strong>jest.fn</strong>函數去模擬回傳資料，jest.fn會建立所謂的<strong>Mock</strong>，Mock常常又稱作間諜，因為它可以模仿函數的行為，最後則是透過<strong>mockResolvedValueOnce</strong>去模擬資料的運作。一連串過程中，可以測試是否連線成功，唯一的差別在於資料是由測試人員自行建立。最後確認回傳的list長度是否為0，就能確認模擬狀況。這裡特別要注意到find的方法和get與query都一樣，差別在於它會回傳Promise，因此會等到模擬fetch完成後才執行。</p>
<p>最後我們執行測試，出現下方的結果。</p>
<p><img src="https://i.imgur.com/XmcR3lu.jpg" alt="test3"></p>
<p>Test Suites共用兩個，因為我們分別有Async和Greeting兩個測試，此外內部分別有1和3個測試，總共有四個測試項目。</p>
<p>-重點回顧-</p>
<ul>
<li>Query回傳DOM節點或Null</li>
<li>Find回傳Promise</li>
<li>Mock透過jest.fn建立</li>
</ul>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>今天把上一篇文章後續的內容討論一下，順便在腦中重新複習一下JEST測試的過程，不過如何針對props去測試還沒有仔細想過，或許會是未來一個有趣的內容。最近花兩天時間讓大腦好好放鬆，看完Netflix上的救命倒數這部美劇，第一季挺不錯的，但第二季就好冗長，跳過的內容相當多。另外艾莉西亞才真的值得珍惜，茱莉亞趕快下去…看的有夠討厭，連恩頭殼壞去，編劇要不要這麼搞?</p>
<p>最後謝謝看到這裡的妳/你們。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/26/React%E7%B3%BB%E5%88%97-JEST%E6%B8%AC%E8%A9%A6%E6%A6%82%E5%BF%B5%E8%88%87%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/26/React%E7%B3%BB%E5%88%97-JEST%E6%B8%AC%E8%A9%A6%E6%A6%82%E5%BF%B5%E8%88%87%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">React系列-JEST測試概念與使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-26 14:49:58" itemprop="dateCreated datePublished" datetime="2021-05-26T14:49:58+08:00">2021-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Test/" itemprop="url" rel="index"><span itemprop="name">Test</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="React-with-JEST"><a href="#React-with-JEST" class="headerlink" title="React with JEST"></a>React with JEST</h3><blockquote>
<p><em>The unexamined life is not worth living</em>.<br><em>― Socrates</em></p>
</blockquote>
<p>這幾天在思考值得研究的主題，但是腦中卻一絲想法都沒有，我想是因為不斷在思考眼前的煩惱，而沒有空出時間給大腦去自由翱翔。不過，今天剛好學習到一門挺有趣的課程也是我想特別討論的主題，在求職過程中，我發現不少資深的職缺都有這部分的能力要求，那就是 Test。</p>
<p>蘇格拉底說:沒有經過審視的生命不值得去體驗。我想沒有經過測試的產品，也不值得人們去使用，程式碼也是一樣的道理，仔細去思考，一個產品只要有瑕疵就要面臨下架或者回收的下場，程式碼又何嘗不是如此，我們立刻進入主題。</p>
<ul>
<li>React 與 JEST<ul>
<li>何謂 JEST</li>
<li>單元測試、整合測試、端對端測試</li>
<li>實際測試</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="React-與-JEST"><a href="#React-與-JEST" class="headerlink" title="React 與 JEST"></a>React 與 JEST</h4><p>今天主要透過 Jest 去測試 React，因為最近比較熟悉 React 框架，覺得透過 React 來學習會比較快上手。一般來說，專案都需要引入第三方的函式庫才能夠去執行測試，不過幸運的是，當我們透過<code>create-react-app</code>指令建立專案時，測試函式庫都會一併安裝完成，在 package.json 檔案中，我們能夠發現下方這三個套件。<br><code>&quot;@testing-library/jest-dom&quot;: &quot;^5.11.6&quot;</code><br><code>&quot;@testing-library/react&quot;: &quot;^11.2.2&quot;</code><br><code>&quot;@testing-library/user-event&quot;: &quot;^12.5.0&quot;</code><br>當然就算沒有也沒關係，手動安裝一下，應該也不成問題。</p>
<hr>
<h5 id="JEST"><a href="#JEST" class="headerlink" title="JEST"></a>JEST</h5><p>首先從 JEST 開始談起，JEST 其實是專門用來測試所有 Javascript 程式碼的測試函式庫，不僅限於 React，同樣可以用於 Vue, Angular, TypeScript, Node 等等…。</p>
<p>JEST 大致上有幾大特點:</p>
<ul>
<li>Fast/Safe: 平行執行測試且確保測試碼擁有唯一的全域狀態</li>
<li>Code Coverage: 透過設定–coverage 旗標來設定測試範圍</li>
<li>Easy Mocking: 執行模擬測試範圍外的程式碼</li>
</ul>
<h5 id="單元測試、整合測試、端對端測試"><a href="#單元測試、整合測試、端對端測試" class="headerlink" title="單元測試、整合測試、端對端測試"></a>單元測試、整合測試、端對端測試</h5><p>在 Coding 的過程中除錯，其實就是一種測試，大致上可以將測試分為以下兩類:</p>
<ul>
<li>手動測試</li>
<li>自動化測試</li>
</ul>
<p>但是我們都知道，只透過手動的測試，必然會出現許多的盲點，因此才會有自動化測試，而自動化又可以根據不同的測試要點，分為以下三類:</p>
<ul>
<li>單元測試(Unit Test)</li>
<li>整合測試(Integration Test)</li>
<li>端對端測試(End-to-End Test)</li>
</ul>
<p><strong>單元測試:</strong> 分離測試獨立區塊、函數、組件<br><strong>整合測試:</strong> 整合測試數個區塊、函數、組件<br><strong>端對端測試:</strong> 專案測試使用者體驗</p>
<p>基本上，最常看到的是單元測試，在一個專案當中，往往會將各種情境都盡可能測試過，因此大部分情況下都會針對個別的小區塊做測試。因此，一個專案可能會有數百數千個單元測試，數百個整合測試與數個端對端測試，根據情況去使用不同的測試。</p>
<p>但是要如何在專案中直接執行測試? 這就需要仰賴 JEST 去執行我們的測試碼，除此之外，我們還需要模擬 React App 的工具，也就是 React Testing 函式庫，上述兩個工具都已經在先前提到過。我們實際來測試看看。</p>
<hr>
<h5 id="實際測試"><a href="#實際測試" class="headerlink" title="實際測試"></a>實際測試</h5><p>首先我們在專案當中建立 components 的資料夾，接著在資料夾中建立 Greeting.js 這個組件，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;Greeting.js&quot;</span><br><span class="line">const Greeting = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Greeting;</span><br></pre></td></tr></table></figure>

<p>現在我們已經有 Greeting 組件可以測試，但是現在要如何撰寫測試檔案? 一般來說，我們會在同一個資料夾直接建立同樣檔名的測試檔案，這裡我們在 components 建立 Greeting.test.js 測試檔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;Greeting.test.js&quot;</span><br><span class="line">import &#123; render, screen &#125; from &#x27;@testing-library/react&#x27;;</span><br><span class="line">import Greeting from &#x27;./Greeting&#x27;;</span><br><span class="line"></span><br><span class="line">test(&#x27;Render Hello World as a text&#x27;, () =&gt; &#123;</span><br><span class="line">    render(&lt;Greeting /&gt;);</span><br><span class="line"></span><br><span class="line">    const findText = screen.getByText(&#x27;Hello World&#x27;, &#123; exact: false &#125;);</span><br><span class="line">    expect(findText).toBeInTheDocument();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>測試Greeting組件要將它匯入測試檔中，此外還必須匯入兩個函數，分別為<strong>render</strong>和<strong>screen</strong>:<br>render: 模擬React渲染<br>screen: 模擬DOM的選取</p>
<p>接著透過JEST的test函數，告訴React這裡是要進行測試的檔案。<code>test(&#39;&#39;, &#123;&#125;)</code>，參數一描述測試用途，參數二則是用來撰寫測試的程式碼，可以注意到我們在這裡透過render(<Greeting />)去模擬React渲染，接著透過screen去尋找是否有<strong>Hello World</strong>的文字，exact代表是否需要完全相符，預設情況下是false。最後透過expect函數去回傳測試結果。</p>
<p>實際跑過<code>npm test</code>就會出現下方測試通過的結果:<br><img src="https://i.imgur.com/9WtRQL7.jpg" alt="test1"></p>
<p>這就是最簡單單單的單元測試，希望想對快速了解JEST和單元測試的朋友們有點幫助。</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>原本想說要一次將測試的文章打完，但才打沒一半就篇幅就已經有點多，因此打算後續再根據這篇文章撰寫整合測試以及處理API的問題。很高興今天自己終於能夠對Test有點基礎概念，希望未來有機會能夠將它派上用場。我想這只能算是初窺JEST的堂奧，但作為認識JEST的第一步，應該算是相當直覺的了。</p>
<p>謝謝看到最後的各位。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/23/JS%E7%B3%BB%E5%88%97-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%85%A5%E9%96%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/23/JS%E7%B3%BB%E5%88%97-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%85%A5%E9%96%80/" class="post-title-link" itemprop="url">JS系列-同步與非同步入門</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-23 10:39:13" itemprop="dateCreated datePublished" datetime="2021-05-23T10:39:13+08:00">2021-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="JS-Async-Await入門"><a href="#JS-Async-Await入門" class="headerlink" title="JS - Async / Await入門"></a>JS - Async / Await入門</h3><blockquote>
<p><em>Be who you are and say what you feel, because those who mind don&#39;t matter, and those who matter don&#39;t mind.</em><br><em>― Bernard M. Baruch</em></p>
</blockquote>
<p>今天來說說關於JS的同步與非同步問題。JS本身屬於<strong>單執行緒</strong>的語言，因此指令會依照順序或者透過特殊語法來控制執行的順序，這就是要來討論的主題。</p>
<ul>
<li>瑪德蓮蛋糕<ul>
<li>同步與不同步(Synchronous/Asynchronous)</li>
<li>Callback</li>
<li>Promise</li>
<li>Async/Await</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="瑪德蓮蛋糕"><a href="#瑪德蓮蛋糕" class="headerlink" title="瑪德蓮蛋糕"></a>瑪德蓮蛋糕</h4><p>透過製作瑪德蓮來學習同步與非同步的概念，我想應該會相當有趣。瑪德蓮蛋糕是我偶爾會在家裡做的一種法式糕點，有興趣的朋友們也不妨嘗試做做看!<br>首先，我們先來看看瑪德蓮的製作過程:</p>
<ul>
<li>準備食材(食譜)<ul>
<li>雞蛋*2</li>
<li>牛奶20g</li>
<li>蜂蜜30g</li>
<li>細砂糖40g</li>
<li>低筋麵粉100g + 泡打粉3匙</li>
<li>無鹽奶油85g</li>
</ul>
</li>
<li>攪拌全蛋</li>
<li>加入砂糖、牛奶</li>
<li>加入過篩的低筋麵粉、泡打粉</li>
<li>加熱無鹽奶油</li>
<li>加入融化奶油攪拌</li>
<li>裝入擠花袋冷藏6小時</li>
<li>烤箱預熱15分鐘170度</li>
<li>擠上模具烘烤15分鐘</li>
<li>取出完成</li>
</ul>
<p>大致上的製作過程如下，其中有許多步驟是需要一步一步去做，但是這裡就牽涉到不少的同步與非同步的概念。</p>
<h5 id="同步與非同步"><a href="#同步與非同步" class="headerlink" title="同步與非同步"></a>同步與非同步</h5><p>同步(Synchronous): 同時執行動作<br>非同步(Asynchronous): 等待完成後執行下一個動作</p>
<p>因為JS特性的關係，我們沒辦法一次執行多個動作，舉例來說: 攪拌全蛋時加熱無鹽奶油，這對於JS本身來說是不可能的。況且有些時候，同步執行不會帶來好處，只會帶來災難，舉例來說，我們如果先預熱烤箱，但是我們根本還沒將瑪德蓮裝入擠花袋並且冷藏6小時，預熱的動作就完全只是徒勞。由此可見，同步與非同步都必須視情況而定。</p>
<p>我們嘗試將完成製作蛋糕的步驟簡單寫成JS的程式碼試試看:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const Madeleine = () =&gt; &#123;</span><br><span class="line">  prepare_ingredient(); </span><br><span class="line">  stir_egg();</span><br><span class="line">  add_sugar_milk();</span><br><span class="line">  add_flour();</span><br><span class="line">  melt_butter();</span><br><span class="line">  add_butter();</span><br><span class="line">  put_to_bag();</span><br><span class="line">  freeze();</span><br><span class="line">  pre_heated();</span><br><span class="line">  bake();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 準備食材</span><br><span class="line">const prepare_ingredient = () =&gt; &#123;&#125;;</span><br><span class="line">// 攪拌全蛋</span><br><span class="line">const stir_egg = () =&gt; &#123;&#125;;</span><br><span class="line">// 加入糖、牛奶</span><br><span class="line">const add_sugar_milk = () =&gt; &#123;&#125;;</span><br><span class="line">// 加入麵粉</span><br><span class="line">const add_flour = () =&gt; &#123;&#125;;</span><br><span class="line">// 加熱奶油</span><br><span class="line">const melt_butter = () =&gt; &#123;&#125;;</span><br><span class="line">// 加入奶油</span><br><span class="line">const add_butter = () =&gt; &#123;&#125;;</span><br><span class="line">// 裝入擠花袋</span><br><span class="line">const put_to_bag = () =&gt; &#123;&#125;;</span><br><span class="line">// 冷藏六小時</span><br><span class="line">const freeze = () =&gt; &#123;&#125;;</span><br><span class="line">// 烤箱預熱 </span><br><span class="line">const pre_heated = () =&gt; &#123;&#125;;</span><br><span class="line">// 烘烤</span><br><span class="line">const bake = () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Madeleine();</span><br></pre></td></tr></table></figure>

<p>我將一連串的動作都寫成函數，接著在最後Madeleine函數去模擬做蛋糕，可以看到我們確實依照食譜的順序去逐一執行動作，JS也會根據程式的先後順序去執行。可是這裡似乎會發生一點問題，問題在哪裡? 問題在於，每一個動作間並沒有彼此認識，舉例來說: 在準備完材料後要攪拌全蛋，但是有沒有可能材料還沒準備完，就開始攪拌全蛋，而導致沒有確認無鹽奶油準備到，而後續造成melet_butter函數執行失敗，這就是此處的問題點所在。</p>
<h5 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h5><p>先來聊聊關於Callback，Callback是JS裡面有趣的函數使用方式。我們先來看一下MDN上面的解釋:<br><strong>A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.</strong><br>簡單來說Callback可以理解成函數執行完後要執行的函數，以上述Madeleine內的步驟來說:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const Madeleine = () =&gt; &#123;</span><br><span class="line">  prepared_Ingredient((res) =&gt; &#123;</span><br><span class="line">    if(res === &#x27;Ingredient prepared.&#x27;)&#123;</span><br><span class="line">      stir_egg((res) =&gt; &#123;</span><br><span class="line">        if(res === &#x27;stir finished.&#x27;)&#123;</span><br><span class="line">          add_sugar_milk(...其他Callback);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          console.log(&#x27;Not stirred yet!&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.log(&#x27;Ingredient not prepared yet!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Madeleine();</span><br></pre></td></tr></table></figure>
<p>上述的prepared_gradient在執行完成後，才呼叫stir_egg()函數，此外也可以透過Callback去處理錯誤的情況，這樣子動作就能夠認識彼此，更能夠了解彼此的優先順序，相較於先前全權交給JS執行緒處理，是不是更令人安心了? 但是這時候就出現所謂的Callback地獄，雖然Callback很方便也很好使用，但是過度使用，就會造成難維護的窘境。</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>MDN的描述:<br><strong>A Promise is an object representing the eventual completion or failure of an asynchronous operation.</strong><br>簡單來說，Promise是表達<strong>非同步執行</strong>結果的一個物件，會根據執行成功或失敗給予開發者回饋。因此，只要回傳Promise物件，我們都能夠使用Promise物件擁有的then函數和catch函數。then函數可以擁有兩個Callback代表Promise執行成功與失敗後的動作，而catch函數只擁有Promise執行失敗後的Callback。直接更改上述烘焙的程式碼如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 假設Madeleine回傳Promise</span><br><span class="line">const Madeleine = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  //暫定每1s成功執行後執行下一個then()</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;Madeleine&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Madeleine()</span><br><span class="line">  .then(prepare_ingredient(), &#123;</span><br><span class="line">    console.log(&#x27;Ingredient not prepared yet!&#x27;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(stir_egg(), &#123;</span><br><span class="line">    console.log(&#x27;Not Stirred yet!);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(add_sugar_milk(), &#123;</span><br><span class="line">    console.log(&#x27;No milk to be added!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...其他的thenc函數</span><br><span class="line">  .catch(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Failed to make Madeleine&#x27;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>透過Promise的使用，我們可以更好的去控管整個製作的流程，也就是將Callback管理的更好。</p>
<p>這邊要特別注意到new Promise這一段程式碼，這裡其實就是將Madeleine指派一個Promise的物件，而new Promise這個物件通常會有兩個參數resolve和reject，前者代表成功後要執行的行為，後者代表失敗後要執行的動作，相似於then和catch的概念，因為then和catch就是透過它們包裝而來的呀!</p>
<h5 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h5><p>最後要講的是JS改版至ES7後的大明星Async和Await，因為它們的出現，我們得以從Promise Chain的枷鎖中獲得解放。實際看一下如何透過Async/Await來改寫我們在Promise的程式碼:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const Madeleine = async() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Start making Madeleine&#x27;);</span><br><span class="line">  const ingredient = await prepared_ingredient();</span><br><span class="line">  const stirredEggs = await stir_egg(eggs);</span><br><span class="line"></span><br><span class="line">  ...其餘動作</span><br><span class="line"></span><br><span class="line">  console.log(ingredient);</span><br><span class="line">  console.log(stirredEggs);</span><br><span class="line">  ...其他結果</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const prepared_ingredient = () =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    if(egg &amp;&amp; milk &amp;&amp; sugar &amp;&amp; honey &amp;&amp; butter &amp;&amp; flour)&#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&#x27;Ingredient is prepared.&#x27;);</span><br><span class="line">      &#125;, 3000);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(&#x27;Ingredient is not prepared!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const stir_egg = (eggs) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    if(eggs === 2)&#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&#x27;Eggs are stirred.&#x27;);</span><br><span class="line">      &#125;, 5000);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(&#x27;No enough eggs!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... 其他動作的函數</span><br></pre></td></tr></table></figure>
<p>透過async的關鍵字，我們可以告知JS要將Madeleine當作非同步的函數，此外因為其他動作函數也會是非同步，可以確定在Madeleine內執行的動作都是await等待過後，才會接續執行，而不會發生動作還沒完成就執行下一個動作的問題。</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>花了很多時間查看許多文章，對於Callback, Promise, Async/Await，釐清了許多問題，但是還是覺得文章打得不夠好，還不能講解的淺顯易懂，代表我自己還沒有真的很熟悉這些概念以及實作方式。期望接下來能夠對這三者有更深的見解，屆時會再來修正這篇文章。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/21/%E9%96%B1%E8%AE%80-%E6%9C%80%E6%9C%89%E7%94%9F%E7%94%A2%E5%8A%9B%E7%9A%84%E4%B8%80%E5%B9%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/21/%E9%96%B1%E8%AE%80-%E6%9C%80%E6%9C%89%E7%94%9F%E7%94%A2%E5%8A%9B%E7%9A%84%E4%B8%80%E5%B9%B4/" class="post-title-link" itemprop="url">閱讀-最有生產力的一年</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-21 17:33:36" itemprop="dateCreated datePublished" datetime="2021-05-21T17:33:36+08:00">2021-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Book/" itemprop="url" rel="index"><span itemprop="name">Book</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Book/Business-Finance/" itemprop="url" rel="index"><span itemprop="name">Business Finance</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="最有生產力的一年-The-Productivity-Project-Chris-Bailey"><a href="#最有生產力的一年-The-Productivity-Project-Chris-Bailey" class="headerlink" title="最有生產力的一年(The Productivity Project) - Chris Bailey"></a>最有生產力的一年(The Productivity Project) - Chris Bailey</h3><p>約莫一周過去，偶爾翻開小讀一番，不知不覺在今天讀完整本。</p>
<p>我想，這本書會吸引一個人，最根本的原因是<strong>不滿足於現狀</strong>的生活和自己。在有數十本的購買清單中，挑選這本書作為自己最優先閱讀的一本書，是因為我想知道自己和他人究竟有什麼區別。我曾經想過他人花的時間比我多，固然能夠成就比我更多，但在我約莫數個月的密集學習後，我發現自己的學習成果相當差。或許這樣的想法過於主觀，但我還是認為自己付出的時間，卻沒有得到我認為應該要有的成效，不免有點失望。當然，這本書還沒有完全解決我的問題，但卻是一本認清自己的最佳書籍。</p>
<ul>
<li>本書觀點</li>
<li>我的看法</li>
<li>結語</li>
</ul>
<hr>
<h4 id="本書觀點"><a href="#本書觀點" class="headerlink" title="本書觀點"></a>本書觀點</h4><p>斷斷續續地讀這本書，說真的有些內容我早已是拋諸腦後，一方面是因為自己記憶力不好，另外一方面則是因為沒有照著書本去實際改善，而只是一昧地閱讀。不過，趁著這篇文章，可以好好溫習一些不錯的想法，因為在閱讀時，我有習慣在不錯的觀點上貼上色紙的習慣。</p>
<p>若有一句話可以歸納「最有生產力的一年」這本書，我想可以用下面這句話試著詮釋:<br><strong>邊緣系統與前額葉皮層間的愛恨情仇</strong></p>
<p>我不確定這兩個專有名詞究竟出現多少次，但至少就我個人看完這本書，就算不特別去記，也已經深植我的腦內海馬迴。喔!就連這個掌管長期記憶的腦內單元都跑出來，想必是Chris Bailey惹的禍。</p>
<p>用簡單的方式理解這兩個專有名詞，我想前者可以聯想至「衝動」，後者可以聯想至「理性」，但我認為這兩個詞彙沒有正負的區分，並不是衝動就不好，也不是理性就好，這全仰賴於生活所遭遇到的情境。</p>
<p>克里斯在開頭不久說: 「生產力與你做多少無關，只與你成就多少有關。」這是一句相當發人省思的一句話，因為在當今社會體制下，許多人依舊活在時間經濟時代，而不是知識經濟時代。在約莫1960s，投入的時間夠多，就會有相對應的報酬，但是在現今的社會下，投入的時間愈多，依舊只會獲得一樣的報酬，而這報酬卻不足以支付快速動盪的世界格局。</p>
<p>影響一個人的生產力主要由「專注力」、「精力」、「時間」三者構成，其中作者闡述時間是最為有限的。透過研究精力、專注力，作者提供我們許多方法去提升自己的生產力，甚至避免在提升生產力過程中的陷阱，赫赫有名的規劃謬誤同樣也出現在本書當中。</p>
<p>作者歸納並且提供給讀者的方法，我認為都有他的用意所在，不管是冥想、重點清單、熱點或白日夢，都是不錯的嘗試方式，在平常鮮少有機會去認識自己的過程當中，實踐某幾項會是不錯的嘗試。</p>
<hr>
<h4 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h4><p>作者說時間是最為有限的，其實我並不完全認同，因為我個人認為專注力和精力的時間都不會超過24H，甚至是遠小於24H。</p>
<p>對於我個人而言最大的收穫是<strong>自我對話</strong>，當然多喝水、運動和冥想我認為也都是非常不錯且看來相當理所當然的概念，不過自我對話卻是一件很值得去思考的事情。作者認為當一個人生產力愈高，自我對話的頻率也會愈高。</p>
<p>很慶幸的是，自我對話中的自我否定的言語居然會高達7成，發現這件事情不是因為悲觀的心情而是人的根性是最大的收穫，頓時這周以來的烏煙瘴氣瞬間少掉一半。</p>
<p><strong>規劃謬誤</strong>也是一個我很喜歡的論點，它雖然看起來有害，但我卻認為它與待辦清單(Todolist)息息相關，因為代辦清單不就是一種規劃嗎? 只不過這樣的規劃通常比較短期，但這又因人而異，因為代辦清單完全可以分長中短去撰寫，但確實認知自己掉落這樣的陷阱是必要的。我就是身受其害的一名，往往都把要讀的書本規劃好，卻根本沒有實踐，而掉落自我安慰的陷阱當中，以為一切都會照著規畫走。</p>
<p>很多情況下，我也經常強迫自己一定要完成才能夠去處理其他的事情，但卻沒有仔細去思考需要令自己適當的放鬆。愈想提高生產力，愈該學習時常的放鬆，而不是強逼迫自己去做該做的事情。以自己在學程式過程，剛開始的時候都會覺得信心滿滿，但一遇到問題就會累積焦燥的心情，甚至看著時間一點一點流逝，就會開始思考自己現在所做的是否有任何意義，也許只是自己的自我滿足，這也是作者認為理解提高生產力背後的意義至關重要的一點。</p>
<p>微小改變往往可以成就更大的目標，但在這其中不可或缺的是將「<strong>未來</strong>」的自己和「<strong>現在</strong>」的自己<strong>連結</strong>在一起，唯有將未來和現在的自己連結，才有可能真正理解自己的所作所為，這是本書我最喜歡的一個觀點。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一頁" aria-label="上一頁" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一頁" aria-label="下一頁" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Matsu Chen</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
