<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chenmatsu.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Nothing more than curiosity">
<meta property="og:type" content="website">
<meta property="og:title" content="Matsu">
<meta property="og:url" content="https://chenmatsu.github.io/page/5/index.html">
<meta property="og:site_name" content="Matsu">
<meta property="og:description" content="Nothing more than curiosity">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Matsu Chen">
<meta property="article:tag" content="Matsu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chenmatsu.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Matsu</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Matsu</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Nothing more than curiosity</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜尋" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Matsu Chen</p>
  <div class="site-description" itemprop="description">Nothing more than curiosity</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/07/%E7%A8%8B%E5%BC%8F%E6%97%A5%E5%B8%B8%E7%B3%BB%E5%88%97-%E5%AE%A3%E5%91%8A%E5%BC%8F%E8%88%87%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E7%9A%84%E5%B7%AE%E7%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/07/%E7%A8%8B%E5%BC%8F%E6%97%A5%E5%B8%B8%E7%B3%BB%E5%88%97-%E5%AE%A3%E5%91%8A%E5%BC%8F%E8%88%87%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E7%9A%84%E5%B7%AE%E7%95%B0/" class="post-title-link" itemprop="url">程式日常-指令式與宣告式程式語言的差異</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-07 12:45:52" itemprop="dateCreated datePublished" datetime="2021-05-07T12:45:52+08:00">2021-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Concept/" itemprop="url" rel="index"><span itemprop="name">Concept</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="分不清指令式與宣告式程式語言"><a href="#分不清指令式與宣告式程式語言" class="headerlink" title="分不清指令式與宣告式程式語言?"></a>分不清指令式與宣告式程式語言?</h3><blockquote>
<p><em>Lack of direction, not lack of time, is the problem. We all have twenty-four hour days.</em><br><em>― Zig Ziglar</em></p>
</blockquote>
<p>今天要來和各位聊聊指令式(Imperative)和宣告式(Declarative)程式語言，聽起來會有點像講古喔!但，仔細想一想，學習一門外語，最難的並不是會使用那門語言，而是語言背後的文化才是真正難以摸透的。我想，程式語言也一樣!因為它也是「語言」!我相信在了解程式語言的歷史後，對於自己在寫的程式會更有深入的理解，而不是在瞬息萬變的世界下走馬看花。</p>
<ul>
<li>指令式程式語言(Imperative Programming)<ul>
<li>低階指令式</li>
<li>高階指令式</li>
</ul>
</li>
<li>宣告式程式語言(Declarative Programming)<ul>
<li>控制流程(Control flow)</li>
<li>資料庫語言(Database Programming) </li>
<li>函式語言(Functional Programming)</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="指令式程式語言-Imperative-Programming"><a href="#指令式程式語言-Imperative-Programming" class="headerlink" title="指令式程式語言(Imperative Programming)"></a>指令式程式語言(Imperative Programming)</h4><p><strong>Imperative programming is a programming paradigm that uses statements that change a program&#39;s state.</strong><br>我們來仔細思考一下這一句擷取自Wiki頁面的敘述。<br>指令式程式語言是使用陳述式語法去改變程式狀態的一種程式範式(典範)。嗯…相當的文謅謅，可不可以用更直覺的方式來理解指令式程式語言? 沒問題，我們馬上看下面的程式碼:</p>
<p>指令式程式語言有分低階與高階</p>
<h5 id="低階指令式程式語言-Low-Level"><a href="#低階指令式程式語言-Low-Level" class="headerlink" title="低階指令式程式語言(Low-Level)"></a>低階指令式程式語言(Low-Level)</h5><p>廣義上來說，低階與高階是相對的概念，以現今來看，就像是C++相對於Python語言就能夠劃分成低階與高階。但狹義上來說，我們劃分低階與高階指令式，可以用組合語言與高階語言來劃分。我們看看下方的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ITER EQU 10           ; number of iterations</span><br><span class="line">OVERHEAD EQU 15       ; 15 for Pentium, 17 for Pentium MMX</span><br><span class="line"></span><br><span class="line">RDTSC MACRO           ; define RDTSC instruction</span><br><span class="line">DB 0FH,31H</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">.DATA</span><br><span class="line"></span><br><span class="line">ALIGN 4</span><br><span class="line">COUNTER DD 0           ; loop counter</span><br><span class="line">TICS DD 0              ; temporary storage of clock</span><br><span class="line">RESULTLIST DD ITER DUP (0)         ; list of test results</span><br><span class="line"></span><br><span class="line">.CODE</span><br><span class="line">BEGIN: MOV [COUNTER],0             ; reset loop counter</span><br><span class="line"></span><br><span class="line">TESTLOOP:                          ; test loop</span><br><span class="line">;**************** Do any initializations here: ******</span><br><span class="line">FINIT</span><br><span class="line">;**************** End of initializations *************</span><br><span class="line">    </span><br><span class="line">RDTSC                   ; read clock counter</span><br><span class="line">MOV [TICS],EAX          ; save count</span><br><span class="line">CLD                     ; non-pairable filler</span><br><span class="line"></span><br><span class="line">REPT 8</span><br><span class="line">NOP                     ; eight NOP&#x27;s to avoid shadowing effect</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">;**************** Put instructions to test here: ************************</span><br><span class="line">FLDPI                                                </span><br><span class="line">FSQRT</span><br><span class="line">RCR EBX,10</span><br><span class="line">FSTP ST</span><br><span class="line">;********************* End of instructions to test ************************</span><br></pre></td></tr></table></figure>
<p>以上的程式碼是組合語言，在我們的定義上來說就是低階的程式語言。現在前後端工程師比較少碰到組合語言，基本上都是處理硬體、韌體時比較有機會接觸到底層的程式語言，也就是低階指令式語言，大部分的情況都是為了使硬體效能最佳化，才會去撰寫組合語言。不過小弟對於組合語言也是一知半解，如果有誤，還請多多指正!</p>
<h5 id="高階指令式程式語言-High-Level"><a href="#高階指令式程式語言-High-Level" class="headerlink" title="高階指令式程式語言(High-Level)"></a>高階指令式程式語言(High-Level)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">bool isPalindrome(int x)</span><br><span class="line">&#123;</span><br><span class="line">     long reverse = 0;</span><br><span class="line">     int compare = x;</span><br><span class="line"></span><br><span class="line">     if(x &lt; 0) </span><br><span class="line">     &#123; </span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     while(x != 0)</span><br><span class="line">     &#123;</span><br><span class="line">         int popin = x % 10;</span><br><span class="line">         x = x / 10;</span><br><span class="line">         reverse = reverse*10 + popin;</span><br><span class="line">     &#125;</span><br><span class="line">     if(reverse == compare) </span><br><span class="line">        return true;</span><br><span class="line">     else </span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程式要確認某一個數字是不是回文(Palindrome)，舉例來說:12321。上述就是指令式程式語言的一種。可以看到說我們必須一步一步地去規劃程式的每一個步驟。首先，我們建立另外一個新的數值，利用取餘(Mod %)的方式，去反向依序填入x的值，最後在經過數值比對去核對數字是否一樣，若一樣則回傳True，相反則回傳False。這就是現今比較常看到的高階指令式程式語言。</p>
<p>指令式程式語言基本上的概念就像上述所說，可以劃分為低階與高階。特別注意的是，在C語言後出現的C+、C++以及Java都屬於<strong>OOP</strong>(Object-Oriented Programmin)的程式語言，但它們本質上依舊屬於指令式程式語言，只是又更上一層樓變得更為高階。其實所謂的指令式沒有想像中的難理解，我們日常在料理的過程，本質上一樣是指令式程式語言。倒不如說，指令式程式語言是從現實生活中，逐步發展出來才是正確的理解方式，有點做什麼(What to)的意味。</p>
<hr>
<h4 id="宣告式程式語言-Declarative-Programming"><a href="#宣告式程式語言-Declarative-Programming" class="headerlink" title="宣告式程式語言(Declarative Programming)"></a>宣告式程式語言(Declarative Programming)</h4><p>同樣地，我們來看看Wiki上面如何定義宣告式程式語言。<br><strong>A style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow.</strong><br>一種不需描述控制流程即可表達運算邏輯的電腦架構與元素風格。嗯…翻譯的似乎不是很到位，不過反覆思考這段話，什麼是不需描述控制流程(Control flow))的架構? 我們先來看看何謂控制流程(Control flow):</p>
<h5 id="控制流程-Control-flow"><a href="#控制流程-Control-flow" class="headerlink" title="控制流程(Control flow)"></a>控制流程(Control flow)</h5><p>控制流程可以用一種方式去理解，那就是「順序」。當程式碼的擺放位置不同時，執行過程就會不同，這就是控制流程的概念。<br>我們來簡單舉個JS的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const world = &#x27;Hello&#x27;;</span><br><span class="line">switch (world) &#123;</span><br><span class="line">  case &#x27;Hello&#x27;:</span><br><span class="line">    console.log(&#x27;Hello world!&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;hello&#x27;:</span><br><span class="line">    console.log(&#x27;World hello!);</span><br><span class="line">    break;</span><br><span class="line">  case &#x27;Hi&#x27;:</span><br><span class="line">    console.log(&#x27;Hi, world!&#x27;);</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    console.log(`Sorry, we are out of $&#123;world&#125;.`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程式碼就是控制流程的概念，可以看到如果改動case的順序，程式流向就會改變。我們暫且討論到這邊，因為重點還是在宣告式程式語言。<br>宣告式語言基本上就是由指令式語言逐步發展過來，因為它的最大區別在於<strong>避免副作用</strong>(Side Effect)。一般來說，撰寫程式免不了會出現副作用，白話一點就是改了這邊的程式碼，壞了那邊的程式碼的概念，因為副作用的其中一種可能性便是改變程式執行的順序，而導致某些程式片段無法成功讀取定義好的函數、物件、陣列等等。</p>
<h5 id="資料庫語言-Database-Programming"><a href="#資料庫語言-Database-Programming" class="headerlink" title="資料庫語言(Database Programming)"></a>資料庫語言(Database Programming)</h5><p>最容易理解也不會令人困惑的非屬於資料庫語言，如：MySQL、PostgreSQL等等的資料庫語言。<br>同樣舉例來看:<br><code>SELECT name FROM tw.male ORDER BY name</code><br> 這就是宣告式程式語言的一種，因為我們並不知道SELECT以及FROM還有ORDER BY的內部程式碼，就算我們更改name以及tw.male的欄位，都不會對整體程式造成任何副作用，頂多回報格式不符合或是查無資料的訊息。</p>
<h5 id="函式語言-Functional-Programming"><a href="#函式語言-Functional-Programming" class="headerlink" title="函式語言(Functional Programming)"></a>函式語言(Functional Programming)</h5><p>函式語言同樣是宣告式程式語言，你正拿來寫網站的JS就是其中的一名。可是你會說寫JS可能會有副作用啊? 沒錯，確實有可能產生，但那只是符合宣告式定義的一種。因為副作用不是必要條件，而是充分條件。換句話說，沒有副作用一定是宣告式程式語言，但有副作用也有可能是宣告式程式語言。直接來看看JS的範例吧!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const filterNums = (...args) =&gt; &#123;</span><br><span class="line">  return args.filter(el =&gt; el &gt; 5);</span><br><span class="line">&#125;</span><br><span class="line">console.log(filterNums(1,3,5,7,9,11,13,15,17));</span><br></pre></td></tr></table></figure>
<p>這段程式碼很眼熟對吧! 因為在ES6快速入門那篇文章也有提到。我們仔細看一下回傳過後的那段程式碼<code>return args.filter(el =&gt; el &gt; 5);</code>這段程式碼讀來沒有任何問題，但是仔細想想filter是什麼? 它是一個函數，可是函數就不會有副作用嗎? 不一定，但至少在這裡它確實不會有副作用，因為不管傳入什麼樣的陣列，都不會影響filter()本身。</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>今天概略講過指令式和宣告式程式語言的差別，因為在Udemy上課程時，講師剛好提到React是宣告式程式語言，就很好奇到底什麼是宣告式程式語言。從React是宣告式語言這一點來看，我們可以知道HTML、CSS、JS都可以歸類為宣告式語言，甚至是XML，畢竟JSX就是JS-XML形式的程式碼，具有標記語言的性質。</p>
<p>這一篇希望對能了解這兩個概念的讀者有點幫助，一開始查資料時，覺得內容蠻多而且還有點乏味。不過仔細去品味程式語言的整個發展，就像發現新世界一樣，一切都是環環相扣。礙於篇幅，還有許多沒有提到，如：DSL(Domain-Specific Language)就沒有提到，但是加上DSL其實就會變得不單純。</p>
<p>那今天就先這樣囉! 我們下回見!</p>
<p>組合語言程式片段來源: <a target="_blank" rel="noopener" href="https://www.csie.ntu.edu.tw/~b5506058/optimize.html">https://www.csie.ntu.edu.tw/~b5506058/optimize.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/06/React%E7%B3%BB%E5%88%97-React%E5%B0%88%E6%A1%88%E5%BB%BA%E7%AB%8B%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/06/React%E7%B3%BB%E5%88%97-React%E5%B0%88%E6%A1%88%E5%BB%BA%E7%AB%8B%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">React系列-開始打造React專案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-06 12:26:24" itemprop="dateCreated datePublished" datetime="2021-05-06T12:26:24+08:00">2021-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="建立屬於你-妳自己的React專案"><a href="#建立屬於你-妳自己的React專案" class="headerlink" title="建立屬於你/妳自己的React專案!"></a>建立屬於你/妳自己的React專案!</h3><blockquote>
<p><em>Yesterday is history, tomorrow is a mystery, today is a gift of God, which is why we call it the present.</em><br><em>― Bill Keane</em><br>今天要講解的東西很輕鬆，就是用指令去建立一個React的專案。<br>–預備知識–</p>
</blockquote>
<ul>
<li>知道命令列介面(Command Line Interface)<ul>
<li>Windows -&gt; cmd</li>
<li>Mac -&gt; terminal</li>
</ul>
</li>
</ul>
<p>–講解流程–</p>
<ul>
<li>安裝Node.js</li>
<li>建立React專案</li>
<li>結語</li>
</ul>
<h4 id="安裝Node-js"><a href="#安裝Node-js" class="headerlink" title="安裝Node.js"></a>安裝Node.js</h4><p>在透過指令安裝React專案前，我們必須先下載Node.js，如果已經安裝好可以直接跳到下一個步驟。</p>
<ul>
<li>Node.js: <a target="_blank" rel="noopener" href="https://nodejs.org/en/">https://nodejs.org/en/</a></li>
</ul>
<p><img src="https://i.imgur.com/w0EDv6j.jpg" alt="node"></p>
<p>直接安裝16.1.0Current版本也可以，接著就照著安裝指示安裝即可。</p>
<h4 id="建立React專案"><a href="#建立React專案" class="headerlink" title="建立React專案"></a>建立React專案</h4><p>安裝完成後打開命令列介面，切換到自己想要建立專案文件夾的路徑後，輸入以下指令建立React的專案。</p>
<p><img src="https://i.imgur.com/OzGORev.jpg" alt="react"></p>
<p>可能會有提示需要安裝create-react-app套件的指示出現，就輸入Y就可以安裝了!<br>接著就會看到專案成功建立完成!把路徑切換到資料夾裡面後，輸入<strong>npm start</strong>就可以成功在本地端(自己的電腦)運行。</p>
<p><img src="https://i.imgur.com/baMBc6M.jpg" alt="react-run"></p>
<p>接著打開瀏覽器就可以看到React專案預設好的畫面!<br><img src="https://i.imgur.com/4ujriXZ.jpg" alt="react-home"></p>
<p>這就是用React開始撰寫網站的第一個步驟!</p>
<p>所謂的套件，在這裡指的是由其他人統整好的函式庫，整個套件含有許多我們在開發React專案的時候需要引入的函式庫等等。因此我們可以知道<strong>create-react-app</strong>就是負責幫我們把需要的工具都整理好，畢竟工欲善其事，必先利其器，就是這個道理。</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>其實這個部分只是想要對開發環境重新做一個認識，順便記錄下來心想或許會有剛接觸到React的程式設計師可以快速閱覽一下。我其實還有遇到webpack版本問題，因為之前在開發的時候把webpack安裝到全域裡，導致建立好的React專案的webpack套件版本被覆蓋過去而跳出警示訊息，所以還是應該好好的把全域弄得乾乾淨淨是最好的選擇。畢竟一天到晚都在搞開發環境，而沒有任何心力專注在開發的話，大概會發瘋吧?</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/06/React%E7%B3%BB%E5%88%97-React%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/06/React%E7%B3%BB%E5%88%97-React%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">React系列-React介紹與基本概念淺談</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-06 11:27:46" itemprop="dateCreated datePublished" datetime="2021-05-06T11:27:46+08:00">2021-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="React介紹與基本概念淺談"><a href="#React介紹與基本概念淺談" class="headerlink" title="React介紹與基本概念淺談"></a>React介紹與基本概念淺談</h3><blockquote>
<p><em>Live as if you were to die tomorrow. Learn as if you were to live forever.</em><br><em>- Mahatma Gandhi</em></p>
</blockquote>
<p>React是近年來盛行的三大框架其一，在ES6後甚至更加盛行。國外統計程式設計師學習React的人數逐年上升，可見React的強勢，因此今天想和大家一起來學習使用React。當然不是隨波逐流，而是在嘗試使用過React後，發現它的強大!更不消說有超級多的第三方函式庫可以使用。那，廢話不多說，我們趕緊往下看!</p>
<ul>
<li>React的定義與用途</li>
<li>React的基本概念<ul>
<li>React的組件(Component)</li>
<li>React的兄弟JSX(JS-XML)</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="React的定義與用途"><a href="#React的定義與用途" class="headerlink" title="React的定義與用途"></a>React的定義與用途</h4><ul>
<li><strong>React是用來打造使用者介面(UI)的JS函式庫。</strong></li>
<li><strong>React是由組件(Component)所組成。</strong></li>
</ul>
<p>讀者可能會想說不是有HTML、CSS、JS就可以打造UI了嗎? 為什麼要大費周章去學習一項新的技術? 其實一項新的技術的產生，都是因為舊有的東西的缺點存在，才會促使新的科技、技術的發展。好比人類覺得走路太久才能到達目的地，所以研究出動力機械，這些道理都是一樣的。可想而知，React產生固然是因為傳統的HTML和CSS在撰寫介面上，不管是維護還是新增介面，盡管有PUG和SCSS這些預處理器多少可以加速開發，但是卻還是有其致命的缺點。</p>
<p>使用傳統的HTML和CSS的主要缺點:</p>
<ul>
<li>頁面轉跳時都需要發送GET請求到Server端後再次渲染頁面</li>
<li>當APP變得複雜且龐大時難以維護以及管理</li>
<li>網頁載入速度慢</li>
</ul>
<p>使用React的優點:</p>
<ul>
<li>整個Web只會在第一次開啟時發送GET請求</li>
<li>以組件的方式開發網站</li>
<li>網頁載入速度超快</li>
</ul>
<hr>
<h4 id="React的基本概念"><a href="#React的基本概念" class="headerlink" title="React的基本概念"></a>React的基本概念</h4><p>網頁最後呈現給使用者的始終是HTML、CSS以及JS。<br>React使用宣告式方法(Declarative Approach)去執行程式，因此開發者只需要專注在程式的狀態(State)，接著React就會幫我們處理JS和DOM的程式碼，聽起來很像魔法，但其實就是我們只需要懂得駕駛React這台跑車，至於引擎是V8還是V12，不懂也沒關係。</p>
<p>有機會我們再來深入研究宣告式(Declarative)與指令式(Imperative)程式設計!</p>
<h5 id="React的組件-Component"><a href="#React的組件-Component" class="headerlink" title="React的組件(Component)"></a>React的組件(Component)</h5><p>React的核心概念就是組件，所謂的組件就是將HTML、CSS、JS三者合在一起，最後再由組件去建立整個使用者介面(UI)。<br>因此組件的優點有:</p>
<ul>
<li>可重複使用(Re-usable)</li>
<li>可回應的(Reactive)</li>
</ul>
<p>React的架構大概如下:<br><img src="https://i.imgur.com/9LTFVrR.png" alt="react"></p>
<p>大概就像圖表一樣的架構，抱歉，我沒有美術天分XDD。</p>
<h5 id="React的兄弟JSX-JS-XML"><a href="#React的兄弟JSX-JS-XML" class="headerlink" title="React的兄弟JSX(JS-XML)"></a>React的兄弟JSX(JS-XML)</h5><p>React的程式碼如下:<br><img src="https://i.imgur.com/Gu2EQPY.jpg" alt="jsx"></p>
<p>剛開始接觸React一定會充滿困惑，會什麼JS檔案裡面的程式碼相當奇怪? 居然包含像是HTML的標記語言，其實這是React開發團隊為了方便撰寫組件所開發的程式碼，叫做JSX(JS-XML)。在渲染畫面前，React會透過第三方函式庫將JSX轉換成瀏覽器讀得懂的方式。</p>
<p>今日回顧:</p>
<ul>
<li>React是HTML、CSS、JS整合後的框架</li>
<li>React的特殊語法JSX</li>
<li>React組件的概念</li>
</ul>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>今天只稍微了解一下React框架以及它的由來，接下來我們就會逐步進入React專案實作囉! 能夠用React實作各種大大小小的網站，用想的就覺得興奮對吧!如果重複打繁瑣的Code還不足以讓你學習它的話，那再接下來的文章你一定會愛上React。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/05/%E6%97%A5%E8%AA%9E%E7%B3%BB%E5%88%97%E8%AC%9B%E8%A7%A3-%E3%81%AF%E3%81%A8%E3%81%8C%E7%9A%84%E5%8D%80%E5%88%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/05/%E6%97%A5%E8%AA%9E%E7%B3%BB%E5%88%97%E8%AC%9B%E8%A7%A3-%E3%81%AF%E3%81%A8%E3%81%8C%E7%9A%84%E5%8D%80%E5%88%A5/" class="post-title-link" itemprop="url">日語系列講解-はとが的區別</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-05 22:51:09" itemprop="dateCreated datePublished" datetime="2021-05-05T22:51:09+08:00">2021-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E8%AA%9E/" itemprop="url" rel="index"><span itemprop="name">日語</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E8%AA%9E/%E6%96%87%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">文法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="はとが的區別"><a href="#はとが的區別" class="headerlink" title="はとが的區別"></a>はとが的區別</h3><blockquote>
<p><em>ささいなことが私たちを慰めるのは、ささいなことが私たちを悩みますからだ。</em><br><em>ー　川端康成</em></p>
</blockquote>
<h4 id="到底要怎麼分はとが這兩個小鬼頭"><a href="#到底要怎麼分はとが這兩個小鬼頭" class="headerlink" title="到底要怎麼分はとが這兩個小鬼頭?"></a>到底要怎麼分はとが這兩個小鬼頭?</h4><p>傻傻分不清，要怎麼知道は和が什麼時候用呢? 看過仿間的文法書，看完還是覺得一頭霧水，網路文章更是五花八門，甚至出現許多的專業名詞還能寫成論文，如: 格助詞、副助詞，最後看完這些名詞最後還是不懂得如何使用は和が。其實就算分不清楚，單憑語感也可以分辨出這兩個助詞的使用時機! 但是我們還是要把語感轉化為文字，一起往下看吧!</p>
<ul>
<li>一次搞定は和と!</li>
<li>「は」的使用時機<ul>
<li>對比</li>
<li>共識</li>
<li>主句</li>
</ul>
</li>
<li>「が」的使用時機<ul>
<li>敘述</li>
<li>提示</li>
<li>子句</li>
</ul>
</li>
<li>用英語來理解は和と!</li>
<li>結語</li>
</ul>
<hr>
<h4 id="一次搞定は和と"><a href="#一次搞定は和と" class="headerlink" title="一次搞定は和と!"></a>一次搞定は和と!</h4><p>直接來看句子: </p>
<ul>
<li> <strong>花は綺麗です</strong></li>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>要怎麼解釋這兩個句子呢? 它們看起來長的一模一樣，根本就是雙胞胎! 它們確實是雙胞胎沒錯，很多時候は和が可以彼此互換，但互換過後就會有點不一樣。<br>先試著從強調的重點來理解:</p>
<ul>
<li><strong>は</strong>強調は後面的詞，在這個例子是綺麗</li>
<li><strong>が</strong>強調が前面的詞，在這個例子是花</li>
</ul>
<p>基本上掌握這個重點，就可以分辨出絕大多數句子的は和が了! 等等，如果這麼簡單那為什麼大家要一直討論呢? 那是因為這兩個小鬼頭很調皮。有時候會偷偷變裝，讓我們分不清楚誰是誰。</p>
<hr>
<h4 id="「は」的使用時機"><a href="#「は」的使用時機" class="headerlink" title="「は」的使用時機"></a>「は」的使用時機</h4><p>は的使用時機可以細分很多種，我們只討論比較常用的三種!</p>
<h5 id="對比"><a href="#對比" class="headerlink" title="對比"></a>對比</h5><p>分辨は的一種很簡單的方式就是透過比對，只要句子能夠看出有比較的意思，那用は肯定沒錯。<br>我們一樣來看剛才舉過的例子:</p>
<ul>
<li> <strong>花は綺麗です</strong></li>
</ul>
<p>從這短短的句子我們可以知道這朵花強調的重點在於<strong>綺麗</strong>(漂亮的)這兩個字，而且可以知道比其他的花還要漂亮，有偷偷比較的意味喔!</p>
<h5 id="共識"><a href="#共識" class="headerlink" title="共識"></a>共識</h5><p>は的很重要的一點就是大家都必須認識它，我們才可以使用!<br>我們來看剛才舉過的例子:</p>
<ul>
<li> <strong>花は綺麗です</strong></li>
</ul>
<p>我們可以知道花必須是我們都知道的一朵花，如果有一個人不知道的話，那不知道在說哪一朵花的人就會沒辦法做比較喔!</p>
<h5 id="主句"><a href="#主句" class="headerlink" title="主句"></a>主句</h5><p>は的最後一個要點就是，它可以獨立為一個句子! 可以想像は是哥哥が是弟弟，は是勇敢的哥哥，會獨自出現在眾人面前。<br>我們再繼續看剛才的例子:</p>
<ul>
<li> <strong>花は綺麗です</strong></li>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>可是看到這裡一定會想說が不是也獨立存在了嗎? 沒錯，它確實作為獨立句子存在，但那是因為這時候的が不是作為主句使用，而是單純強調前方的花來使用。<br>因此我們在這裡需要看看其他的句子:</p>
<ul>
<li><strong>おじいさんは、花が咲いた時 笑えました。</strong></li>
</ul>
<p>在上述的句子當中，我們拆開成各自的句子:</p>
<ul>
<li> <strong>おじいさんは笑えました</strong></li>
<li> <strong>花が咲いた時</strong>　</li>
</ul>
<p>我們可以發現おじいさんは笑えました直接讀起來也沒有問題，但是花が咲いた時讀起來就會有種話還沒說完的感覺，不妨把が想成是因為太害羞，而還有話沒說出來吧!</p>
<hr>
<h4 id="「が」的使用時機"><a href="#「が」的使用時機" class="headerlink" title="「が」的使用時機"></a>「が」的使用時機</h4><p>が的使用時機我們一樣只討論比較常用的三種!</p>
<h5 id="敘述"><a href="#敘述" class="headerlink" title="敘述"></a>敘述</h5><p>が有種比較客觀的感覺，像是單純在敘述，而不加油添醋對眼前發生的事情預設立場。<br>我們同樣看最一開始的例子:</p>
<ul>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>在這句花が綺麗です，我們可以知道在說花很美，單純地說花很美，沒有一點點個人的偏見。</p>
<h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>が特別重要的概念是作為提示使用，因為我們剛才提過は是必須在大家都知道的情況下使用，但若遇到真的有人不知道的時候呢? 這個時候很簡單，我們就要先用が來開場白，讓大家都知道我們在說什麼。在這裡我們同樣需要舉其他的例子，才能理解這個差異:</p>
<ul>
<li> <strong>花が咲きました</strong></li>
<li> <strong>本当ですか？</strong>　</li>
</ul>
<p>上面的句子看起來像是單純的敘述，但是下方若接了一個問句，我們就可以知道花が咲きました是為了讓大家先了解花已經開了，但可能有人還不知道花開了，我們不能自己認為大家都要知道花已經盛開，畢竟が很膽小，有些話還沒說出來。</p>
<h5 id="子句"><a href="#子句" class="headerlink" title="子句"></a>子句</h5><p>は作為主句的例子就可以完美詮釋が身為子句的角色。</p>
<ul>
<li> <strong>おじいさんは笑えました</strong></li>
<li> <strong>花が咲いた時</strong>　</li>
</ul>
<p>因為が很膽小，所以總是要躲在は的背後喔!</p>
<hr>
<h4 id="用英語來理解は和と"><a href="#用英語來理解は和と" class="headerlink" title="用英語來理解は和と!"></a>用英語來理解は和と!</h4><p>試著嘗試用英語理解的話，那麼は大概就會像是定冠詞<strong>the</strong>，が則像是冠詞<strong>an</strong></p>
<ul>
<li> <strong>花は綺麗です</strong></li>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>則上面的句子就會是</p>
<ul>
<li> <strong>A flower is beautiful.</strong></li>
<li> <strong>The flower is beautiful.</strong></li>
</ul>
<p>回到我們最一開始的重點:</p>
<ul>
<li><strong>は</strong>強調は後面的詞，在這個例子是綺麗</li>
<li><strong>が</strong>強調が前面的詞，在這個例子是花</li>
</ul>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>希望這樣對於各位理解は和が能夠更深入，我個人覺得理解到這個程度在閱讀文章上應該不會有太大的障礙，當然我們可以繼續細分更多使用的情境，不過有時候會想花那麼多時間，卻只搞定這兩個小鬼頭，會不會太不划算了呢? 學習日語的路途很有趣! 不要放棄，一起學下去!! 接下來有時間的話會來寫動詞的變換部分，我曾經也在動詞苦惱了許久。日語的動詞變化真的是很需要花時間，對於初學者來說，更是容易搞混的重點，希望我能用淺顯易懂的方式傳達出去。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/05/JS%E7%B3%BB%E5%88%97-ES6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%96%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/05/JS%E7%B3%BB%E5%88%97-ES6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%96%80/" class="post-title-link" itemprop="url">JS系列-ES6快速入門</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-05 14:40:50" itemprop="dateCreated datePublished" datetime="2021-05-05T14:40:50+08:00">2021-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="JS-ES6快速入門"><a href="#JS-ES6快速入門" class="headerlink" title="JS - ES6快速入門"></a>JS - ES6快速入門</h3><blockquote>
<p><em>The only true wisdom is in knowing you know nothing.</em><br><em>- Socrates</em></p>
</blockquote>
<h4 id="JS語法釐清"><a href="#JS語法釐清" class="headerlink" title="JS語法釐清"></a>JS語法釐清</h4><p>今天重溫JS的基礎，徹底了解ES5與ES6間的差異，那麼廢話不多說，趕緊來看!</p>
<ul>
<li>變數命名 let &amp; const</li>
<li>箭頭函數 ES6<ul>
<li>ES5函數</li>
<li>ES6函數</li>
</ul>
</li>
<li>觀念釐清 Export &amp; Import</li>
<li>類別與繼承 Class </li>
<li>展開/其餘運算子 Spread &amp; Rest</li>
<li>拆解 Destructuring</li>
<li>原始型態和參照型態 Primitive &amp; Reference</li>
<li>結語</li>
</ul>
<p>以下範例程式碼都可以在JSbin實際執行看看喔!不妨動手試試吧!<br><strong>JSbin: <a target="_blank" rel="noopener" href="https://jsbin.com/?js,console">https://jsbin.com/?js,console</a></strong></p>
<hr>
<h4 id="變數命名-let-amp-const"><a href="#變數命名-let-amp-const" class="headerlink" title="變數命名 let &amp; const"></a>變數命名 let &amp; const</h4><p>在ES6，var開始出現分身，就是let和const! 簡單來說，它們的功用都是用來定義變數，實際舉例:<br><code>var number = 5;</code><br><code>let number = 5;</code><br><code>const number = 5;</code><br>一般區別在於let所命名的變數是可變的，const所命名的變數則是不可變的。<br>其實還有Scope的問題，但暫且不討論那一塊。</p>
<hr>
<h4 id="箭頭函數-ES6"><a href="#箭頭函數-ES6" class="headerlink" title="箭頭函數 ES6"></a>箭頭函數 ES6</h4><p>接下來比較大的改變莫過於箭頭函數，若沒有事先了解，肯定出現ES5和ES6是不同程式語言的錯覺。</p>
<h5 id="ES5函數"><a href="#ES5函數" class="headerlink" title="ES5函數"></a>ES5函數</h5><p>首先先來看看ES5的函數寫法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function say(name)&#123;</span><br><span class="line">  console.log(name + &quot; Hey! You cool!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say(&#x27;Johnny&#x27;);</span><br></pre></td></tr></table></figure>
<p>在ES5撰寫函數的時候，會先寫下<strong>function</strong>這個關鍵字建立函數，接著再寫上函數的名稱，以本例來說<strong>say</strong>就是函數的名稱，往後在呼叫這個函數時則要寫上<strong>say</strong>，而括號()內則填入參數，所以呼叫時我在這裡傳入<strong>Johnny</strong>，這就是ES5典型的函數呼叫方式。<br>實際在JSbin執行過後可以得到結果是<code>&quot;Johnny Hey! You cool!&quot;</code></p>
<h5 id="ES6函數"><a href="#ES6函數" class="headerlink" title="ES6函數"></a>ES6函數</h5><p>根據ES5的函數寫法，我們來改寫成ES6的箭頭函數:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const say = (name) =&gt; &#123;</span><br><span class="line">  console.log(name + &quot; Hey! You cool!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">say(&#x27;Johnny&#x27;);</span><br></pre></td></tr></table></figure>
<p>一般來說要將ES6寫成等同於ES5的程式碼都必須指派到某變數，同樣可以根據函數是否會更動而宣告為let或者是const。我們可以看到參數的傳遞寫在等號後方，接著才接上箭頭函數。好處在於簡潔的語法外，最重要的優點在於<strong>this</strong>關鍵字的範圍變得更加明瞭，而不會像ES5函數的this常常會超出我們所想。<br>同樣在JSbin執行過後可以得到結果也是<code>&quot;Johnny Hey! You cool!&quot;</code></p>
<p>TIP:<br><strong>單一參數</strong>，箭頭函數可以簡化成下方寫法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const say = name =&gt; console.log(name + &quot; Hey! You cool!&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>無參數或多參數</strong>，括號()不得省略:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const say = () =&gt; console.log(&quot;Hey! You cool!&quot;);</span><br><span class="line">const say = (fname, lname) =&gt; console.log(fname + &quot; &quot; + lname + &quot; Hey! You cool!&quot;);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="觀念釐清-Export-amp-Import"><a href="#觀念釐清-Export-amp-Import" class="headerlink" title="觀念釐清 Export &amp; Import"></a>觀念釐清 Export &amp; Import</h4><p>在專案當中，把程式模組化是一件相當明智的選擇。<br>首先模組化的檔案必須先匯出<strong>Export</strong>，才能由其他程式匯入<strong>Import</strong>後使用。<br>匯出Export有兩種方式，我們以ES6的函數為例:<br>–預設匯出–<br><code>export default say</code></p>
<p>–命名匯出–<br><code>export const say = (name) =&gt; console.log(&quot; Hey! You cool!&quot;)</code><br><code>export const name = &quot;Johnny&quot;</code><br>預設匯出的檔案只有一個模組，以上例來說就是只匯出say這個函數，命名匯出則是會根據名稱匯出不同的模組，以上例來說就是匯出say這個函數外，還能夠再匯出其他函數或變數。</p>
<p>匯入Import則會根據匯出的方式對應:<br>–預設匯入–<br><code>import say from &#39;./say.js&#39;</code><br>當然say可以當成alias任意命名，如下:<br><code>import greet from &#39;./say.js&#39;</code></p>
<p>–命名匯入–<br><code>import &#123;say&#125; from &#39;./say.js&#39;</code><br><code>import &#123;name&#125; from &#39;./say.js&#39;</code><br>可以清楚看到若是預設匯入則可以任意命名，但若是命名匯入則必須指定要匯入的函數或變數等等。<br>總結來看，一個檔案只能包含一個預設匯出及數個命名匯出，因此若檔案包含數個模組或變數等，我們也可以一次匯入所有的模組如下:<br><code>import * as all from &#39;./say.js</code><br>存取則可以透過<strong>all.say</strong>和<strong>all.name</strong>存取我們匯出的模組或變數。</p>
<hr>
<h4 id="類別與繼承-Class"><a href="#類別與繼承-Class" class="headerlink" title="類別與繼承 Class"></a>類別與繼承 Class</h4><p>噹噹噹，Java跟Javascript就像是Ham跟Hamburger，除了開頭三個英文字其他都不一樣，但自從ES6加入了Class後，它們的相似性又提高了一點，對，就是那麼一點。對於熟悉物件導向程式語言的各位來說，肯定是一件再熟悉不過的事情，不過我們還是來看看JS的Class吧!畢竟三大框架Angular,React,Vue幾乎可以說是完全基於它的概念而發展出來。<br>關鍵字起頭不廢話:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fish &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.species = &#x27;fish&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  swim () &#123;</span><br><span class="line">    console.log(&quot;swims...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = new Fish();</span><br><span class="line">console.log(shark.species);</span><br><span class="line">shark.swim();</span><br></pre></td></tr></table></figure>
<p>上方定義魚的類別，裡面有一個建構子與方法Swim。典型的類別寫法，同時也是比較<strong>舊</strong>的寫法。constructor可以理解為一開始實體化(初始化)時就具備的東西，以Fish類別來說，鯊魚剛生出來就有個名字叫做’fish’。<br>實際執行後顯示結果<code>&quot;fish&quot;</code>跟<code>&quot;swims...&quot;</code></p>
<p>接著我們來看看繼承的範例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Shark extends Fish&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.name = &#x27;shark&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  swim() &#123;</span><br><span class="line">    console.log(&quot;swims pretty fast...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = new Shark();</span><br><span class="line">console.log(shark.species);</span><br><span class="line">console.log(shark.name);</span><br><span class="line">shark.swim();</span><br></pre></td></tr></table></figure>
<p>鯊魚這個類別繼承魚，鯊魚這次完成進化，游得非常快而且有個更酷炫的名字shark!需要特別注意的是，繼承父類別Fish必須要寫上super()才可以確保父類別屬性的建構子也經過實體化。<br>不過這樣看下來好像JS在class上沒有什麼獨到之處啊? No.No..No…<br>以上的程式碼都能改寫成更有ES6的味道:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Fish &#123;</span><br><span class="line">  species = &#x27;fish&#x27;;</span><br><span class="line">  swim = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;swims...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shark extends Fish &#123;</span><br><span class="line">  name = &#x27;shark&#x27;;</span><br><span class="line">  swim = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;swims pretty fast...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = new Shark();</span><br><span class="line">console.log(shark.species);</span><br><span class="line">console.log(shark.name);</span><br><span class="line">shark.swim();</span><br></pre></td></tr></table></figure>
<p>看到JS有多潮了嗎?大概就跟鯊魚一樣潮，海中霸主。可以注意到在JS裡的Class並不是純粹的Class而是經過簡化的Class，所以常常可以聽到有人說JS的Class是類Class也是有點道理在。因為ES6幫我們處理許多像是constructor跟super()，在JS這些都可以省略不寫，因此我們只需要專注在High-Level的部分，裝備穿好了，還不趕快出發嗎?</p>
<hr>
<h4 id="展開-其餘運算子-Spread-amp-Rest"><a href="#展開-其餘運算子-Spread-amp-Rest" class="headerlink" title="展開/其餘運算子 Spread &amp; Rest"></a>展開/其餘運算子 Spread &amp; Rest</h4><p>ES6可以與箭頭函數與之比肩的大概就非屬於展開和其餘運算子了，讓我們來了解它們的各自功能。<br><strong>展開運算子(Spread Operator): 將陣列元素或者是物件屬性分割出來</strong><br><strong>其餘運算子(Rest Operator): 將一連串的函數參數合併到陣列中</strong></p>
<p>不需要懷疑，這兩個運算子放在一起講就是因為它們的寫法一樣都是**…**，沒錯就是點點點，想必大家看完心中也是點點點，但我們立刻來抽絲剝繭。<br>展開運算子其實相當好理解，就是將陣列分開再使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const oldYear = [2018, 2019, 2020];</span><br><span class="line">const newYear = [...oldYear, 2021];</span><br><span class="line">console.log(newYear);</span><br></pre></td></tr></table></figure>
<p>我們可以了解到newYear第一個參數…oldYear會先將oldYear這個陣列本身切割開來成為單一元素，接著再建立一個新的陣列給newYear並且再加上後續的參數。<br>實際執行後顯示結果<code>[2018, 2019, 2020, 2021]</code>。<br>同樣地，我們也可以將展開運算子運用在物件上:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const fish = &#123;</span><br><span class="line">  species: &#x27;fish&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = &#123;</span><br><span class="line">  ...fish,</span><br><span class="line">  name: &#x27;shark&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>實際執行後顯示結果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[object Object] &#123;</span><br><span class="line">  name: &quot;shark&quot;,</span><br><span class="line">  species: &quot;fish&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以發現fish的屬性一樣被添加到shark裡面，這就是展開運算子的功能，帶來意想不到的便捷性，尤其是在複製陣列或物件身上。</p>
<p>接著來討論其餘運算子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const filterNums = (...args) =&gt; &#123;</span><br><span class="line">  return args.filter(el =&gt; el &gt; 5);</span><br><span class="line">&#125;</span><br><span class="line">console.log(filterNums(1,3,5,7,9,11,13,15,17));</span><br></pre></td></tr></table></figure>
<p>我們在這個函數傳入其餘運算子(…args)，args可以任意命名，接著我們回傳args的內建函數filter。因為args在經過其餘運算子後已經轉換為陣列，因此可以套用陣列的內建方法，如:sort(), map(), slice(), splice()等等的方法。特別注意的是filterNums()並不能傳入一組陣列，會造成其餘運算子無法將陣列轉換成功而直接回傳空陣列。<br>實際執行後顯示<code>[7, 9, 11, 13, 15, 17]</code></p>
<hr>
<h4 id="拆解-Destructuring"><a href="#拆解-Destructuring" class="headerlink" title="拆解 Destructuring"></a>拆解 Destructuring</h4><p>藉由拆解我們可以很容易的去存取陣列或物件裡面的元素或屬性，我們實際來看點例子。<br>首先是陣列:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const breakMeUp = [2, 0, 2, 1, &quot;is&quot;, &quot;cool&quot;];</span><br><span class="line">const [a, b, , d, e] = breakMeUp;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(d);</span><br><span class="line">console.log(e);</span><br></pre></td></tr></table></figure>
<p>透過直接拆解陣列可以對應到breakMeUp陣列裡面的元素，而不需要透過其他方式去索引。<br>實際執行後顯示<br>接著是物件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Shark = &#123;</span><br><span class="line">  species: &#x27;fish&#x27;,</span><br><span class="line">  name: &#x27;shark&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;species&#125; = Shark;</span><br><span class="line">console.log(species);</span><br><span class="line">console.log(name);</span><br></pre></td></tr></table></figure>
<p>物件的拆解就像是一對一的對應，中括號{}內寫的變數能夠對應到物件的屬性，就能夠讀取，如果沒有對應的屬性則會回傳undefined.<br>實際結果:<code>&quot;fish&quot;和&quot;Undefined&quot;</code></p>
<hr>
<h4 id="原始型態和參照型態-Primitive-amp-Reference"><a href="#原始型態和參照型態-Primitive-amp-Reference" class="headerlink" title="原始型態和參照型態 Primitive &amp; Reference"></a>原始型態和參照型態 Primitive &amp; Reference</h4><p>終於來到本日的最後一個段落，喘口氣~茶。<br>JS最重要的概念大概在於釐清原始型態(Primitive)和參照型態(Reference)，基本上數值、字串、布林值、Null、undefined都隸屬於原始型態，至於在JS常常操作的陣列與物件則是所謂的參照型態。<br>等等，什麼型態? 難不成我還得會開二、三檔，接著伸縮機關槍嗎? 不會可能真的打不出機關槍來。<br>首先是原始型態:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let num = 1111;</span><br><span class="line">let num2 = num;</span><br><span class="line">console.log(num);</span><br><span class="line">console.log(num2);</span><br><span class="line">num = 2222;</span><br><span class="line">console.log(num); </span><br><span class="line">console.log(num2)</span><br></pre></td></tr></table></figure>
<p>上述程式我們可以理解到何謂原始型態，簡單來說就是<strong>參值</strong>(Call By Value)，因此num在後續變更後並不會改動num2的值。可以理解為num2模仿num蓋房子，蓋完後即便num改建，num2的房子還是長的跟num之前的房子一樣。原理就是因為num2其實擁有自己的記憶體位置0x0f03。<br>實際執行結果顯示:<code>1111 1111 2222 1111</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fish = &#123;</span><br><span class="line">  species: &#x27;fish&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const shark = fish;</span><br><span class="line">console.log(shark.species);</span><br><span class="line">fish.species = &#x27;animal&#x27;</span><br><span class="line">console.log(shark.species);</span><br><span class="line">shark.species = &#x27;fish&#x27;;</span><br><span class="line">console.log(fish.species);</span><br></pre></td></tr></table></figure>
<p>上述程式我們理解參照型態，簡單來說就是<strong>參址</strong>(Call By Reference)，既然它們住的地方都一樣，只要有人去改動房子的，那自然它們就會彼此影響，換句話說，fish和shark都參照到同一個記憶體位址，理解這一點後，就可以理解JS不論是展開、其餘運算子還是陣列內建方法，都會產生新的陣列的原因在，一方面是要避免副作用，試想如果不小心改動陣列，卻把最一開始的值都搞混了，那還需要繼承什麼呢? 可能哪天fish的種類變成dog都不一定對吧?<br>實際執行結果顯示:<code>&quot;fish&quot;, &quot;animal&quot;, &quot;fish&quot;</code></p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>哇! 今天一個興起就把文章打好打滿，花了不少時間。其實會突然想打這篇文章主要是因為在網路上學React的課程，剛好講師複習JS一些比較需要去注意的改動,<br>像是箭頭函數、展開運算子、類別其實都逐漸讓JS在程式語言的世界裡稱霸，當然還是有許多很好的語言，但JS的強勢卻是無庸置疑，以前或許沒人敢說，但現在肯定大家都會認同JS是很強勢的語言，即便它是弱型態語言，仔細想一想JS根本就是扮豬吃老虎，有夠過分，但大家還是對它愛不釋手，我也是。</p>
<p>希望今天的系列文能夠快速幫助需要的人複習ES5.6間的改動，其實有些許改動牽連到ES7，有機會再拿出來討論，相信應該不會等上太久的時間。許多細節沒有講到，但我想理解基本概念，等到實務上遇到問題再去深入理解也不遲，畢竟要學的東西太多了!</p>
<p>謝謝各位看到最後!!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一頁" aria-label="上一頁" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一頁" aria-label="下一頁" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Matsu Chen</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
