<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chenmatsu.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Nothing more than curiosity">
<meta property="og:type" content="website">
<meta property="og:title" content="Matsu">
<meta property="og:url" content="https://chenmatsu.github.io/page/5/index.html">
<meta property="og:site_name" content="Matsu">
<meta property="og:description" content="Nothing more than curiosity">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Matsu Chen">
<meta property="article:tag" content="Matsu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chenmatsu.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Matsu</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Matsu</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Nothing more than curiosity</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜尋" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Matsu Chen</p>
  <div class="site-description" itemprop="description">Nothing more than curiosity</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/06/React%E7%B3%BB%E5%88%97-React%E5%B0%88%E6%A1%88%E5%BB%BA%E7%AB%8B%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/06/React%E7%B3%BB%E5%88%97-React%E5%B0%88%E6%A1%88%E5%BB%BA%E7%AB%8B%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">React系列-開始打造React專案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-06 12:26:24" itemprop="dateCreated datePublished" datetime="2021-05-06T12:26:24+08:00">2021-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="建立屬於你-妳自己的React專案"><a href="#建立屬於你-妳自己的React專案" class="headerlink" title="建立屬於你/妳自己的React專案!"></a>建立屬於你/妳自己的React專案!</h3><blockquote>
<p><em>Yesterday is history, tomorrow is a mystery, today is a gift of God, which is why we call it the present.</em><br><em>― Bill Keane</em><br>今天要講解的東西很輕鬆，就是用指令去建立一個React的專案。<br>–預備知識–</p>
</blockquote>
<ul>
<li>知道命令列介面(Command Line Interface)<ul>
<li>Windows -&gt; cmd</li>
<li>Mac -&gt; terminal</li>
</ul>
</li>
</ul>
<p>–講解流程–</p>
<ul>
<li>安裝Node.js</li>
<li>建立React專案</li>
<li>結語</li>
</ul>
<h4 id="安裝Node-js"><a href="#安裝Node-js" class="headerlink" title="安裝Node.js"></a>安裝Node.js</h4><p>在透過指令安裝React專案前，我們必須先下載Node.js，如果已經安裝好可以直接跳到下一個步驟。</p>
<ul>
<li>Node.js: <a target="_blank" rel="noopener" href="https://nodejs.org/en/">https://nodejs.org/en/</a></li>
</ul>
<p><img src="https://i.imgur.com/w0EDv6j.jpg" alt="node"></p>
<p>直接安裝16.1.0Current版本也可以，接著就照著安裝指示安裝即可。</p>
<h4 id="建立React專案"><a href="#建立React專案" class="headerlink" title="建立React專案"></a>建立React專案</h4><p>安裝完成後打開命令列介面，切換到自己想要建立專案文件夾的路徑後，輸入以下指令建立React的專案。</p>
<p><img src="https://i.imgur.com/OzGORev.jpg" alt="react"></p>
<p>可能會有提示需要安裝create-react-app套件的指示出現，就輸入Y就可以安裝了!<br>接著就會看到專案成功建立完成!把路徑切換到資料夾裡面後，輸入<strong>npm start</strong>就可以成功在本地端(自己的電腦)運行。</p>
<p><img src="https://i.imgur.com/baMBc6M.jpg" alt="react-run"></p>
<p>接著打開瀏覽器就可以看到React專案預設好的畫面!<br><img src="https://i.imgur.com/4ujriXZ.jpg" alt="react-home"></p>
<p>這就是用React開始撰寫網站的第一個步驟!</p>
<p>所謂的套件，在這裡指的是由其他人統整好的函式庫，整個套件含有許多我們在開發React專案的時候需要引入的函式庫等等。因此我們可以知道<strong>create-react-app</strong>就是負責幫我們把需要的工具都整理好，畢竟工欲善其事，必先利其器，就是這個道理。</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>其實這個部分只是想要對開發環境重新做一個認識，順便記錄下來心想或許會有剛接觸到React的程式設計師可以快速閱覽一下。我其實還有遇到webpack版本問題，因為之前在開發的時候把webpack安裝到全域裡，導致建立好的React專案的webpack套件版本被覆蓋過去而跳出警示訊息，所以還是應該好好的把全域弄得乾乾淨淨是最好的選擇。畢竟一天到晚都在搞開發環境，而沒有任何心力專注在開發的話，大概會發瘋吧?</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/06/React%E7%B3%BB%E5%88%97-React%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/06/React%E7%B3%BB%E5%88%97-React%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">React系列-React介紹與基本概念淺談</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-06 11:27:46" itemprop="dateCreated datePublished" datetime="2021-05-06T11:27:46+08:00">2021-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="React介紹與基本概念淺談"><a href="#React介紹與基本概念淺談" class="headerlink" title="React介紹與基本概念淺談"></a>React介紹與基本概念淺談</h3><blockquote>
<p><em>Live as if you were to die tomorrow. Learn as if you were to live forever.</em><br><em>- Mahatma Gandhi</em></p>
</blockquote>
<p>React是近年來盛行的三大框架其一，在ES6後甚至更加盛行。國外統計程式設計師學習React的人數逐年上升，可見React的強勢，因此今天想和大家一起來學習使用React。當然不是隨波逐流，而是在嘗試使用過React後，發現它的強大!更不消說有超級多的第三方函式庫可以使用。那，廢話不多說，我們趕緊往下看!</p>
<ul>
<li>React的定義與用途</li>
<li>React的基本概念<ul>
<li>React的組件(Component)</li>
<li>React的兄弟JSX(JS-XML)</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="React的定義與用途"><a href="#React的定義與用途" class="headerlink" title="React的定義與用途"></a>React的定義與用途</h4><ul>
<li><strong>React是用來打造使用者介面(UI)的JS函式庫。</strong></li>
<li><strong>React是由組件(Component)所組成。</strong></li>
</ul>
<p>讀者可能會想說不是有HTML、CSS、JS就可以打造UI了嗎? 為什麼要大費周章去學習一項新的技術? 其實一項新的技術的產生，都是因為舊有的東西的缺點存在，才會促使新的科技、技術的發展。好比人類覺得走路太久才能到達目的地，所以研究出動力機械，這些道理都是一樣的。可想而知，React產生固然是因為傳統的HTML和CSS在撰寫介面上，不管是維護還是新增介面，盡管有PUG和SCSS這些預處理器多少可以加速開發，但是卻還是有其致命的缺點。</p>
<p>使用傳統的HTML和CSS的主要缺點:</p>
<ul>
<li>頁面轉跳時都需要發送GET請求到Server端後再次渲染頁面</li>
<li>當APP變得複雜且龐大時難以維護以及管理</li>
<li>網頁載入速度慢</li>
</ul>
<p>使用React的優點:</p>
<ul>
<li>整個Web只會在第一次開啟時發送GET請求</li>
<li>以組件的方式開發網站</li>
<li>網頁載入速度超快</li>
</ul>
<hr>
<h4 id="React的基本概念"><a href="#React的基本概念" class="headerlink" title="React的基本概念"></a>React的基本概念</h4><p>網頁最後呈現給使用者的始終是HTML、CSS以及JS。<br>React使用宣告式方法(Declarative Approach)去執行程式，因此開發者只需要專注在程式的狀態(State)，接著React就會幫我們處理JS和DOM的程式碼，聽起來很像魔法，但其實就是我們只需要懂得駕駛React這台跑車，至於引擎是V8還是V12，不懂也沒關係。</p>
<p>有機會我們再來深入研究宣告式(Declarative)與指令式(Imperative)程式設計!</p>
<h5 id="React的組件-Component"><a href="#React的組件-Component" class="headerlink" title="React的組件(Component)"></a>React的組件(Component)</h5><p>React的核心概念就是組件，所謂的組件就是將HTML、CSS、JS三者合在一起，最後再由組件去建立整個使用者介面(UI)。<br>因此組件的優點有:</p>
<ul>
<li>可重複使用(Re-usable)</li>
<li>可回應的(Reactive)</li>
</ul>
<p>React的架構大概如下:<br><img src="https://i.imgur.com/9LTFVrR.png" alt="react"></p>
<p>大概就像圖表一樣的架構，抱歉，我沒有美術天分XDD。</p>
<h5 id="React的兄弟JSX-JS-XML"><a href="#React的兄弟JSX-JS-XML" class="headerlink" title="React的兄弟JSX(JS-XML)"></a>React的兄弟JSX(JS-XML)</h5><p>React的程式碼如下:<br><img src="https://i.imgur.com/Gu2EQPY.jpg" alt="jsx"></p>
<p>剛開始接觸React一定會充滿困惑，會什麼JS檔案裡面的程式碼相當奇怪? 居然包含像是HTML的標記語言，其實這是React開發團隊為了方便撰寫組件所開發的程式碼，叫做JSX(JS-XML)。在渲染畫面前，React會透過第三方函式庫將JSX轉換成瀏覽器讀得懂的方式。</p>
<p>今日回顧:</p>
<ul>
<li>React是HTML、CSS、JS整合後的框架</li>
<li>React的特殊語法JSX</li>
<li>React組件的概念</li>
</ul>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>今天只稍微了解一下React框架以及它的由來，接下來我們就會逐步進入React專案實作囉! 能夠用React實作各種大大小小的網站，用想的就覺得興奮對吧!如果重複打繁瑣的Code還不足以讓你學習它的話，那再接下來的文章你一定會愛上React。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/05/%E6%97%A5%E8%AA%9E%E7%B3%BB%E5%88%97%E8%AC%9B%E8%A7%A3-%E3%81%AF%E3%81%A8%E3%81%8C%E7%9A%84%E5%8D%80%E5%88%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/05/%E6%97%A5%E8%AA%9E%E7%B3%BB%E5%88%97%E8%AC%9B%E8%A7%A3-%E3%81%AF%E3%81%A8%E3%81%8C%E7%9A%84%E5%8D%80%E5%88%A5/" class="post-title-link" itemprop="url">日語系列講解-はとが的區別</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-05 22:51:09" itemprop="dateCreated datePublished" datetime="2021-05-05T22:51:09+08:00">2021-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E8%AA%9E/" itemprop="url" rel="index"><span itemprop="name">日語</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%97%A5%E8%AA%9E/%E6%96%87%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">文法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="はとが的區別"><a href="#はとが的區別" class="headerlink" title="はとが的區別"></a>はとが的區別</h3><blockquote>
<p><em>ささいなことが私たちを慰めるのは、ささいなことが私たちを悩みますからだ。</em><br><em>ー　川端康成</em></p>
</blockquote>
<h4 id="到底要怎麼分はとが這兩個小鬼頭"><a href="#到底要怎麼分はとが這兩個小鬼頭" class="headerlink" title="到底要怎麼分はとが這兩個小鬼頭?"></a>到底要怎麼分はとが這兩個小鬼頭?</h4><p>傻傻分不清，要怎麼知道は和が什麼時候用呢? 看過仿間的文法書，看完還是覺得一頭霧水，網路文章更是五花八門，甚至出現許多的專業名詞還能寫成論文，如: 格助詞、副助詞，最後看完這些名詞最後還是不懂得如何使用は和が。其實就算分不清楚，單憑語感也可以分辨出這兩個助詞的使用時機! 但是我們還是要把語感轉化為文字，一起往下看吧!</p>
<ul>
<li>一次搞定は和と!</li>
<li>「は」的使用時機<ul>
<li>對比</li>
<li>共識</li>
<li>主句</li>
</ul>
</li>
<li>「が」的使用時機<ul>
<li>敘述</li>
<li>提示</li>
<li>子句</li>
</ul>
</li>
<li>用英語來理解は和と!</li>
<li>結語</li>
</ul>
<hr>
<h4 id="一次搞定は和と"><a href="#一次搞定は和と" class="headerlink" title="一次搞定は和と!"></a>一次搞定は和と!</h4><p>直接來看句子: </p>
<ul>
<li> <strong>花は綺麗です</strong></li>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>要怎麼解釋這兩個句子呢? 它們看起來長的一模一樣，根本就是雙胞胎! 它們確實是雙胞胎沒錯，很多時候は和が可以彼此互換，但互換過後就會有點不一樣。<br>先試著從強調的重點來理解:</p>
<ul>
<li><strong>は</strong>強調は後面的詞，在這個例子是綺麗</li>
<li><strong>が</strong>強調が前面的詞，在這個例子是花</li>
</ul>
<p>基本上掌握這個重點，就可以分辨出絕大多數句子的は和が了! 等等，如果這麼簡單那為什麼大家要一直討論呢? 那是因為這兩個小鬼頭很調皮。有時候會偷偷變裝，讓我們分不清楚誰是誰。</p>
<hr>
<h4 id="「は」的使用時機"><a href="#「は」的使用時機" class="headerlink" title="「は」的使用時機"></a>「は」的使用時機</h4><p>は的使用時機可以細分很多種，我們只討論比較常用的三種!</p>
<h5 id="對比"><a href="#對比" class="headerlink" title="對比"></a>對比</h5><p>分辨は的一種很簡單的方式就是透過比對，只要句子能夠看出有比較的意思，那用は肯定沒錯。<br>我們一樣來看剛才舉過的例子:</p>
<ul>
<li> <strong>花は綺麗です</strong></li>
</ul>
<p>從這短短的句子我們可以知道這朵花強調的重點在於<strong>綺麗</strong>(漂亮的)這兩個字，而且可以知道比其他的花還要漂亮，有偷偷比較的意味喔!</p>
<h5 id="共識"><a href="#共識" class="headerlink" title="共識"></a>共識</h5><p>は的很重要的一點就是大家都必須認識它，我們才可以使用!<br>我們來看剛才舉過的例子:</p>
<ul>
<li> <strong>花は綺麗です</strong></li>
</ul>
<p>我們可以知道花必須是我們都知道的一朵花，如果有一個人不知道的話，那不知道在說哪一朵花的人就會沒辦法做比較喔!</p>
<h5 id="主句"><a href="#主句" class="headerlink" title="主句"></a>主句</h5><p>は的最後一個要點就是，它可以獨立為一個句子! 可以想像は是哥哥が是弟弟，は是勇敢的哥哥，會獨自出現在眾人面前。<br>我們再繼續看剛才的例子:</p>
<ul>
<li> <strong>花は綺麗です</strong></li>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>可是看到這裡一定會想說が不是也獨立存在了嗎? 沒錯，它確實作為獨立句子存在，但那是因為這時候的が不是作為主句使用，而是單純強調前方的花來使用。<br>因此我們在這裡需要看看其他的句子:</p>
<ul>
<li><strong>おじいさんは、花が咲いた時 笑えました。</strong></li>
</ul>
<p>在上述的句子當中，我們拆開成各自的句子:</p>
<ul>
<li> <strong>おじいさんは笑えました</strong></li>
<li> <strong>花が咲いた時</strong>　</li>
</ul>
<p>我們可以發現おじいさんは笑えました直接讀起來也沒有問題，但是花が咲いた時讀起來就會有種話還沒說完的感覺，不妨把が想成是因為太害羞，而還有話沒說出來吧!</p>
<hr>
<h4 id="「が」的使用時機"><a href="#「が」的使用時機" class="headerlink" title="「が」的使用時機"></a>「が」的使用時機</h4><p>が的使用時機我們一樣只討論比較常用的三種!</p>
<h5 id="敘述"><a href="#敘述" class="headerlink" title="敘述"></a>敘述</h5><p>が有種比較客觀的感覺，像是單純在敘述，而不加油添醋對眼前發生的事情預設立場。<br>我們同樣看最一開始的例子:</p>
<ul>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>在這句花が綺麗です，我們可以知道在說花很美，單純地說花很美，沒有一點點個人的偏見。</p>
<h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>が特別重要的概念是作為提示使用，因為我們剛才提過は是必須在大家都知道的情況下使用，但若遇到真的有人不知道的時候呢? 這個時候很簡單，我們就要先用が來開場白，讓大家都知道我們在說什麼。在這裡我們同樣需要舉其他的例子，才能理解這個差異:</p>
<ul>
<li> <strong>花が咲きました</strong></li>
<li> <strong>本当ですか？</strong>　</li>
</ul>
<p>上面的句子看起來像是單純的敘述，但是下方若接了一個問句，我們就可以知道花が咲きました是為了讓大家先了解花已經開了，但可能有人還不知道花開了，我們不能自己認為大家都要知道花已經盛開，畢竟が很膽小，有些話還沒說出來。</p>
<h5 id="子句"><a href="#子句" class="headerlink" title="子句"></a>子句</h5><p>は作為主句的例子就可以完美詮釋が身為子句的角色。</p>
<ul>
<li> <strong>おじいさんは笑えました</strong></li>
<li> <strong>花が咲いた時</strong>　</li>
</ul>
<p>因為が很膽小，所以總是要躲在は的背後喔!</p>
<hr>
<h4 id="用英語來理解は和と"><a href="#用英語來理解は和と" class="headerlink" title="用英語來理解は和と!"></a>用英語來理解は和と!</h4><p>試著嘗試用英語理解的話，那麼は大概就會像是定冠詞<strong>the</strong>，が則像是冠詞<strong>an</strong></p>
<ul>
<li> <strong>花は綺麗です</strong></li>
<li> <strong>花が綺麗です</strong>　</li>
</ul>
<p>則上面的句子就會是</p>
<ul>
<li> <strong>A flower is beautiful.</strong></li>
<li> <strong>The flower is beautiful.</strong></li>
</ul>
<p>回到我們最一開始的重點:</p>
<ul>
<li><strong>は</strong>強調は後面的詞，在這個例子是綺麗</li>
<li><strong>が</strong>強調が前面的詞，在這個例子是花</li>
</ul>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>希望這樣對於各位理解は和が能夠更深入，我個人覺得理解到這個程度在閱讀文章上應該不會有太大的障礙，當然我們可以繼續細分更多使用的情境，不過有時候會想花那麼多時間，卻只搞定這兩個小鬼頭，會不會太不划算了呢? 學習日語的路途很有趣! 不要放棄，一起學下去!! 接下來有時間的話會來寫動詞的變換部分，我曾經也在動詞苦惱了許久。日語的動詞變化真的是很需要花時間，對於初學者來說，更是容易搞混的重點，希望我能用淺顯易懂的方式傳達出去。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/05/JS%E7%B3%BB%E5%88%97-ES6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%96%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/05/JS%E7%B3%BB%E5%88%97-ES6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%96%80/" class="post-title-link" itemprop="url">JS系列-ES6快速入門</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-05 14:40:50" itemprop="dateCreated datePublished" datetime="2021-05-05T14:40:50+08:00">2021-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="JS-ES6快速入門"><a href="#JS-ES6快速入門" class="headerlink" title="JS - ES6快速入門"></a>JS - ES6快速入門</h3><blockquote>
<p><em>The only true wisdom is in knowing you know nothing.</em><br><em>- Socrates</em></p>
</blockquote>
<h4 id="JS語法釐清"><a href="#JS語法釐清" class="headerlink" title="JS語法釐清"></a>JS語法釐清</h4><p>今天重溫JS的基礎，徹底了解ES5與ES6間的差異，那麼廢話不多說，趕緊來看!</p>
<ul>
<li>變數命名 let &amp; const</li>
<li>箭頭函數 ES6<ul>
<li>ES5函數</li>
<li>ES6函數</li>
</ul>
</li>
<li>觀念釐清 Export &amp; Import</li>
<li>類別與繼承 Class </li>
<li>展開/其餘運算子 Spread &amp; Rest</li>
<li>拆解 Destructuring</li>
<li>原始型態和參照型態 Primitive &amp; Reference</li>
<li>結語</li>
</ul>
<p>以下範例程式碼都可以在JSbin實際執行看看喔!不妨動手試試吧!<br><strong>JSbin: <a target="_blank" rel="noopener" href="https://jsbin.com/?js,console">https://jsbin.com/?js,console</a></strong></p>
<hr>
<h4 id="變數命名-let-amp-const"><a href="#變數命名-let-amp-const" class="headerlink" title="變數命名 let &amp; const"></a>變數命名 let &amp; const</h4><p>在ES6，var開始出現分身，就是let和const! 簡單來說，它們的功用都是用來定義變數，實際舉例:<br><code>var number = 5;</code><br><code>let number = 5;</code><br><code>const number = 5;</code><br>一般區別在於let所命名的變數是可變的，const所命名的變數則是不可變的。<br>其實還有Scope的問題，但暫且不討論那一塊。</p>
<hr>
<h4 id="箭頭函數-ES6"><a href="#箭頭函數-ES6" class="headerlink" title="箭頭函數 ES6"></a>箭頭函數 ES6</h4><p>接下來比較大的改變莫過於箭頭函數，若沒有事先了解，肯定出現ES5和ES6是不同程式語言的錯覺。</p>
<h5 id="ES5函數"><a href="#ES5函數" class="headerlink" title="ES5函數"></a>ES5函數</h5><p>首先先來看看ES5的函數寫法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function say(name)&#123;</span><br><span class="line">  console.log(name + &quot; Hey! You cool!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say(&#x27;Johnny&#x27;);</span><br></pre></td></tr></table></figure>
<p>在ES5撰寫函數的時候，會先寫下<strong>function</strong>這個關鍵字建立函數，接著再寫上函數的名稱，以本例來說<strong>say</strong>就是函數的名稱，往後在呼叫這個函數時則要寫上<strong>say</strong>，而括號()內則填入參數，所以呼叫時我在這裡傳入<strong>Johnny</strong>，這就是ES5典型的函數呼叫方式。<br>實際在JSbin執行過後可以得到結果是<code>&quot;Johnny Hey! You cool!&quot;</code></p>
<h5 id="ES6函數"><a href="#ES6函數" class="headerlink" title="ES6函數"></a>ES6函數</h5><p>根據ES5的函數寫法，我們來改寫成ES6的箭頭函數:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const say = (name) =&gt; &#123;</span><br><span class="line">  console.log(name + &quot; Hey! You cool!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">say(&#x27;Johnny&#x27;);</span><br></pre></td></tr></table></figure>
<p>一般來說要將ES6寫成等同於ES5的程式碼都必須指派到某變數，同樣可以根據函數是否會更動而宣告為let或者是const。我們可以看到參數的傳遞寫在等號後方，接著才接上箭頭函數。好處在於簡潔的語法外，最重要的優點在於<strong>this</strong>關鍵字的範圍變得更加明瞭，而不會像ES5函數的this常常會超出我們所想。<br>同樣在JSbin執行過後可以得到結果也是<code>&quot;Johnny Hey! You cool!&quot;</code></p>
<p>TIP:<br><strong>單一參數</strong>，箭頭函數可以簡化成下方寫法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const say = name =&gt; console.log(name + &quot; Hey! You cool!&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>無參數或多參數</strong>，括號()不得省略:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const say = () =&gt; console.log(&quot;Hey! You cool!&quot;);</span><br><span class="line">const say = (fname, lname) =&gt; console.log(fname + &quot; &quot; + lname + &quot; Hey! You cool!&quot;);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="觀念釐清-Export-amp-Import"><a href="#觀念釐清-Export-amp-Import" class="headerlink" title="觀念釐清 Export &amp; Import"></a>觀念釐清 Export &amp; Import</h4><p>在專案當中，把程式模組化是一件相當明智的選擇。<br>首先模組化的檔案必須先匯出<strong>Export</strong>，才能由其他程式匯入<strong>Import</strong>後使用。<br>匯出Export有兩種方式，我們以ES6的函數為例:<br>–預設匯出–<br><code>export default say</code></p>
<p>–命名匯出–<br><code>export const say = (name) =&gt; console.log(&quot; Hey! You cool!&quot;)</code><br><code>export const name = &quot;Johnny&quot;</code><br>預設匯出的檔案只有一個模組，以上例來說就是只匯出say這個函數，命名匯出則是會根據名稱匯出不同的模組，以上例來說就是匯出say這個函數外，還能夠再匯出其他函數或變數。</p>
<p>匯入Import則會根據匯出的方式對應:<br>–預設匯入–<br><code>import say from &#39;./say.js&#39;</code><br>當然say可以當成alias任意命名，如下:<br><code>import greet from &#39;./say.js&#39;</code></p>
<p>–命名匯入–<br><code>import &#123;say&#125; from &#39;./say.js&#39;</code><br><code>import &#123;name&#125; from &#39;./say.js&#39;</code><br>可以清楚看到若是預設匯入則可以任意命名，但若是命名匯入則必須指定要匯入的函數或變數等等。<br>總結來看，一個檔案只能包含一個預設匯出及數個命名匯出，因此若檔案包含數個模組或變數等，我們也可以一次匯入所有的模組如下:<br><code>import * as all from &#39;./say.js</code><br>存取則可以透過<strong>all.say</strong>和<strong>all.name</strong>存取我們匯出的模組或變數。</p>
<hr>
<h4 id="類別與繼承-Class"><a href="#類別與繼承-Class" class="headerlink" title="類別與繼承 Class"></a>類別與繼承 Class</h4><p>噹噹噹，Java跟Javascript就像是Ham跟Hamburger，除了開頭三個英文字其他都不一樣，但自從ES6加入了Class後，它們的相似性又提高了一點，對，就是那麼一點。對於熟悉物件導向程式語言的各位來說，肯定是一件再熟悉不過的事情，不過我們還是來看看JS的Class吧!畢竟三大框架Angular,React,Vue幾乎可以說是完全基於它的概念而發展出來。<br>關鍵字起頭不廢話:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fish &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.species = &#x27;fish&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  swim () &#123;</span><br><span class="line">    console.log(&quot;swims...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = new Fish();</span><br><span class="line">console.log(shark.species);</span><br><span class="line">shark.swim();</span><br></pre></td></tr></table></figure>
<p>上方定義魚的類別，裡面有一個建構子與方法Swim。典型的類別寫法，同時也是比較<strong>舊</strong>的寫法。constructor可以理解為一開始實體化(初始化)時就具備的東西，以Fish類別來說，鯊魚剛生出來就有個名字叫做’fish’。<br>實際執行後顯示結果<code>&quot;fish&quot;</code>跟<code>&quot;swims...&quot;</code></p>
<p>接著我們來看看繼承的範例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Shark extends Fish&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">    this.name = &#x27;shark&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  swim() &#123;</span><br><span class="line">    console.log(&quot;swims pretty fast...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = new Shark();</span><br><span class="line">console.log(shark.species);</span><br><span class="line">console.log(shark.name);</span><br><span class="line">shark.swim();</span><br></pre></td></tr></table></figure>
<p>鯊魚這個類別繼承魚，鯊魚這次完成進化，游得非常快而且有個更酷炫的名字shark!需要特別注意的是，繼承父類別Fish必須要寫上super()才可以確保父類別屬性的建構子也經過實體化。<br>不過這樣看下來好像JS在class上沒有什麼獨到之處啊? No.No..No…<br>以上的程式碼都能改寫成更有ES6的味道:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Fish &#123;</span><br><span class="line">  species = &#x27;fish&#x27;;</span><br><span class="line">  swim = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;swims...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shark extends Fish &#123;</span><br><span class="line">  name = &#x27;shark&#x27;;</span><br><span class="line">  swim = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;swims pretty fast...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = new Shark();</span><br><span class="line">console.log(shark.species);</span><br><span class="line">console.log(shark.name);</span><br><span class="line">shark.swim();</span><br></pre></td></tr></table></figure>
<p>看到JS有多潮了嗎?大概就跟鯊魚一樣潮，海中霸主。可以注意到在JS裡的Class並不是純粹的Class而是經過簡化的Class，所以常常可以聽到有人說JS的Class是類Class也是有點道理在。因為ES6幫我們處理許多像是constructor跟super()，在JS這些都可以省略不寫，因此我們只需要專注在High-Level的部分，裝備穿好了，還不趕快出發嗎?</p>
<hr>
<h4 id="展開-其餘運算子-Spread-amp-Rest"><a href="#展開-其餘運算子-Spread-amp-Rest" class="headerlink" title="展開/其餘運算子 Spread &amp; Rest"></a>展開/其餘運算子 Spread &amp; Rest</h4><p>ES6可以與箭頭函數與之比肩的大概就非屬於展開和其餘運算子了，讓我們來了解它們的各自功能。<br><strong>展開運算子(Spread Operator): 將陣列元素或者是物件屬性分割出來</strong><br><strong>其餘運算子(Rest Operator): 將一連串的函數參數合併到陣列中</strong></p>
<p>不需要懷疑，這兩個運算子放在一起講就是因為它們的寫法一樣都是**…**，沒錯就是點點點，想必大家看完心中也是點點點，但我們立刻來抽絲剝繭。<br>展開運算子其實相當好理解，就是將陣列分開再使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const oldYear = [2018, 2019, 2020];</span><br><span class="line">const newYear = [...oldYear, 2021];</span><br><span class="line">console.log(newYear);</span><br></pre></td></tr></table></figure>
<p>我們可以了解到newYear第一個參數…oldYear會先將oldYear這個陣列本身切割開來成為單一元素，接著再建立一個新的陣列給newYear並且再加上後續的參數。<br>實際執行後顯示結果<code>[2018, 2019, 2020, 2021]</code>。<br>同樣地，我們也可以將展開運算子運用在物件上:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const fish = &#123;</span><br><span class="line">  species: &#x27;fish&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shark = &#123;</span><br><span class="line">  ...fish,</span><br><span class="line">  name: &#x27;shark&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>實際執行後顯示結果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[object Object] &#123;</span><br><span class="line">  name: &quot;shark&quot;,</span><br><span class="line">  species: &quot;fish&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以發現fish的屬性一樣被添加到shark裡面，這就是展開運算子的功能，帶來意想不到的便捷性，尤其是在複製陣列或物件身上。</p>
<p>接著來討論其餘運算子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const filterNums = (...args) =&gt; &#123;</span><br><span class="line">  return args.filter(el =&gt; el &gt; 5);</span><br><span class="line">&#125;</span><br><span class="line">console.log(filterNums(1,3,5,7,9,11,13,15,17));</span><br></pre></td></tr></table></figure>
<p>我們在這個函數傳入其餘運算子(…args)，args可以任意命名，接著我們回傳args的內建函數filter。因為args在經過其餘運算子後已經轉換為陣列，因此可以套用陣列的內建方法，如:sort(), map(), slice(), splice()等等的方法。特別注意的是filterNums()並不能傳入一組陣列，會造成其餘運算子無法將陣列轉換成功而直接回傳空陣列。<br>實際執行後顯示<code>[7, 9, 11, 13, 15, 17]</code></p>
<hr>
<h4 id="拆解-Destructuring"><a href="#拆解-Destructuring" class="headerlink" title="拆解 Destructuring"></a>拆解 Destructuring</h4><p>藉由拆解我們可以很容易的去存取陣列或物件裡面的元素或屬性，我們實際來看點例子。<br>首先是陣列:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const breakMeUp = [2, 0, 2, 1, &quot;is&quot;, &quot;cool&quot;];</span><br><span class="line">const [a, b, , d, e] = breakMeUp;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(d);</span><br><span class="line">console.log(e);</span><br></pre></td></tr></table></figure>
<p>透過直接拆解陣列可以對應到breakMeUp陣列裡面的元素，而不需要透過其他方式去索引。<br>實際執行後顯示<br>接著是物件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Shark = &#123;</span><br><span class="line">  species: &#x27;fish&#x27;,</span><br><span class="line">  name: &#x27;shark&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;species&#125; = Shark;</span><br><span class="line">console.log(species);</span><br><span class="line">console.log(name);</span><br></pre></td></tr></table></figure>
<p>物件的拆解就像是一對一的對應，中括號{}內寫的變數能夠對應到物件的屬性，就能夠讀取，如果沒有對應的屬性則會回傳undefined.<br>實際結果:<code>&quot;fish&quot;和&quot;Undefined&quot;</code></p>
<hr>
<h4 id="原始型態和參照型態-Primitive-amp-Reference"><a href="#原始型態和參照型態-Primitive-amp-Reference" class="headerlink" title="原始型態和參照型態 Primitive &amp; Reference"></a>原始型態和參照型態 Primitive &amp; Reference</h4><p>終於來到本日的最後一個段落，喘口氣~茶。<br>JS最重要的概念大概在於釐清原始型態(Primitive)和參照型態(Reference)，基本上數值、字串、布林值、Null、undefined都隸屬於原始型態，至於在JS常常操作的陣列與物件則是所謂的參照型態。<br>等等，什麼型態? 難不成我還得會開二、三檔，接著伸縮機關槍嗎? 不會可能真的打不出機關槍來。<br>首先是原始型態:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let num = 1111;</span><br><span class="line">let num2 = num;</span><br><span class="line">console.log(num);</span><br><span class="line">console.log(num2);</span><br><span class="line">num = 2222;</span><br><span class="line">console.log(num); </span><br><span class="line">console.log(num2)</span><br></pre></td></tr></table></figure>
<p>上述程式我們可以理解到何謂原始型態，簡單來說就是<strong>參值</strong>(Call By Value)，因此num在後續變更後並不會改動num2的值。可以理解為num2模仿num蓋房子，蓋完後即便num改建，num2的房子還是長的跟num之前的房子一樣。原理就是因為num2其實擁有自己的記憶體位置0x0f03。<br>實際執行結果顯示:<code>1111 1111 2222 1111</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fish = &#123;</span><br><span class="line">  species: &#x27;fish&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const shark = fish;</span><br><span class="line">console.log(shark.species);</span><br><span class="line">fish.species = &#x27;animal&#x27;</span><br><span class="line">console.log(shark.species);</span><br><span class="line">shark.species = &#x27;fish&#x27;;</span><br><span class="line">console.log(fish.species);</span><br></pre></td></tr></table></figure>
<p>上述程式我們理解參照型態，簡單來說就是<strong>參址</strong>(Call By Reference)，既然它們住的地方都一樣，只要有人去改動房子的，那自然它們就會彼此影響，換句話說，fish和shark都參照到同一個記憶體位址，理解這一點後，就可以理解JS不論是展開、其餘運算子還是陣列內建方法，都會產生新的陣列的原因在，一方面是要避免副作用，試想如果不小心改動陣列，卻把最一開始的值都搞混了，那還需要繼承什麼呢? 可能哪天fish的種類變成dog都不一定對吧?<br>實際執行結果顯示:<code>&quot;fish&quot;, &quot;animal&quot;, &quot;fish&quot;</code></p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>哇! 今天一個興起就把文章打好打滿，花了不少時間。其實會突然想打這篇文章主要是因為在網路上學React的課程，剛好講師複習JS一些比較需要去注意的改動,<br>像是箭頭函數、展開運算子、類別其實都逐漸讓JS在程式語言的世界裡稱霸，當然還是有許多很好的語言，但JS的強勢卻是無庸置疑，以前或許沒人敢說，但現在肯定大家都會認同JS是很強勢的語言，即便它是弱型態語言，仔細想一想JS根本就是扮豬吃老虎，有夠過分，但大家還是對它愛不釋手，我也是。</p>
<p>希望今天的系列文能夠快速幫助需要的人複習ES5.6間的改動，其實有些許改動牽連到ES7，有機會再拿出來討論，相信應該不會等上太久的時間。許多細節沒有講到，但我想理解基本概念，等到實務上遇到問題再去深入理解也不遲，畢竟要學的東西太多了!</p>
<p>謝謝各位看到最後!!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/02/Hexo%E7%B3%BB%E5%88%97%20-%20%E9%96%8B%E5%95%9F%E6%97%85%E9%80%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/02/Hexo%E7%B3%BB%E5%88%97%20-%20%E9%96%8B%E5%95%9F%E6%97%85%E9%80%94/" class="post-title-link" itemprop="url">Hexo系列-開啟旅途</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-02 16:17:35" itemprop="dateCreated datePublished" datetime="2021-05-02T16:17:35+08:00">2021-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="踏上Hexo的旅途，開始為自己做紀錄"><a href="#踏上Hexo的旅途，開始為自己做紀錄" class="headerlink" title="踏上Hexo的旅途，開始為自己做紀錄"></a>踏上Hexo的旅途，開始為自己做紀錄</h3><blockquote>
<p><em>In three words I can sum up everything I have learned about life: it goes on.</em><br>- <em>Robert Frost</em></p>
</blockquote>
<p><strong>種一棵樹最好的時機是十年前，其次是現在。</strong><br>是否曾經想過紀錄生活的點滴，是否想要開始改變自己。每一天晚上睡前都想著要變得更好，隔一天早起床卻又是日復一日的一天，走到今日，是否忘記那些人生感動的片刻，是否覺得許多事情都變得不再有意義，面對生活的壓力，是否開始漫無目的，好像人本來就是要不斷奔波直到跑不動為止。</p>
<p>很多時候的沒意義，都只是因為忘記那感動的瞬間，可還記得聽見過讓你感動的音樂，可還記得令人樂此不疲的一件，可還記得最美的幾個瞬間。如果能夠回味，一定會很懷念吧!</p>
<h4 id="前言-用Hexo記住生活的每個片刻"><a href="#前言-用Hexo記住生活的每個片刻" class="headerlink" title="前言 用Hexo記住生活的每個片刻"></a>前言 用Hexo記住生活的每個片刻</h4><p>今天開始Hexo系列文，希望能對想要有自己的Blog，卻苦於一些制式Blog不是那麼討喜的人，能夠帶來一些幫助，少走一點冤枉路。那，我們馬上開始吧!<br>以下是本篇文章講解的順序，盡情挑選自己想看的重點吧!</p>
<ul>
<li>Hexo是什麼?</li>
<li>踏上旅途整理行李 -&gt; Git與Node</li>
<li>正式趟上Hexo旅途</li>
<li>出發吧! Hexo</li>
<li>屬於每個人的Hexo路</li>
<li>結語</li>
</ul>
<hr>
<h4 id="Hexo是什麼"><a href="#Hexo是什麼" class="headerlink" title="Hexo是什麼?"></a>Hexo是什麼?</h4><p>簡單來說，Hexo是一個<strong>部落格的框架</strong>，部落客只需要撰寫<strong>Markdown</strong>格式的檔案就可以上傳到自己的部落格上，當然在這之前需要自己先踏上名為Hexo的這條路，才可以享受一路上的風景。Hexo非常容易入門，更有相當多元的主題(模板)可以套用到自己的部落格上，以更客製化的方式。</p>
<p>Hexo為想要有自己部落格卻又不想使用現有市面部落格平台的人，無疑帶來許多好處，具有高度客製化外，還能夠享受自己架設網站的感覺。對於我自己來說，雖然不盡理想卻是一個現況最佳的作法，畢竟完完全全架起自己的網站，知識層面的時間成本就相當高，若再算上購買網域和虛擬主機，長期下來也是相當可觀的。</p>
<hr>
<h4 id="踏上旅途整理行李-Git與Node"><a href="#踏上旅途整理行李-Git與Node" class="headerlink" title="踏上旅途整理行李 Git與Node"></a>踏上旅途整理行李 Git與Node</h4><p>執行Hexo需要使用到Git與Node，首先根據以下網址下載安裝對應電腦作業系統(OS)的檔案:</p>
<ol>
<li> 安裝Node.js <a target="_blank" rel="noopener" href="https://nodejs.org/en/">https://nodejs.org/en/</a></li>
<li> 安裝Git <a target="_blank" rel="noopener" href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></li>
</ol>
<p><img src="https://i.imgur.com/NLE6I8P.jpg" alt="Version"></p>
<p>接下來會在Command Line(命令提示字元)上執行指令，以縮寫cmd代表Command Line，在macOS則是Terminal。<br>以上是我的Node和Git版本，檢驗是否成功在cmd輸入:</p>
<ul>
<li>node –version</li>
<li>git –version</li>
</ul>
<p>需要特別注意的是Hexo要求Node的版本必須高於 Node.js 10.13，官方推薦最好是 Node.js 12.0以上，安裝最新版的話基本上就沒有問題。</p>
<hr>
<h4 id="正式趟上Hexo旅途"><a href="#正式趟上Hexo旅途" class="headerlink" title="正式趟上Hexo旅途"></a>正式趟上Hexo旅途</h4><p>成功安裝Node和Git後，我們可以直接在cmd執行以下的指令安裝Hexo:<br><code>&gt; npm install -g hexo-cli</code> (-g代表global) </p>
<p>若想單純安裝在專案的話則執行以下指令安裝Hexo:<br><code>&gt; npm install hexo</code></p>
<p>在一切都平安無事安裝完後，讓我們正式來看看Hexo一路上有什麼特別的風景吧!<br>首先執行下方指令:<br><code>&gt;hexo init &lt;folder name&gt;</code> (init代表initialize: 初始化)<br><code>&gt;cd &lt;folder name&gt;</code>(cd代表change direcoty: 切換路徑)<br><code>&gt;npm install</code> (安裝需要的套件)</p>
<p>所謂的<strong>初始化</strong>是將既有的檔案回復預設的樣子，如果沒有檔案則建立檔案，把它<strong>想成手機的回復原廠設定</strong>就可以理解了，對吧!至於npm install則是會安裝我們在初始化<strong>hexo init</strong>時，產生一個叫做package.json的檔案裡面寫好的檔案，在執行後才會將所需的套件安裝到這個資料夾裡面，需要安裝的套件都寫在<strong>dependencies</strong>裡面。</p>
<p><img src="https://i.imgur.com/fH6vqTq.jpg" alt="package.json"></p>
<p>不過在最新版Hexo執行初始化的時候，都會順便安裝完成，不執行npm install我想也是沒問題的!<br>接著可以看到建立好的資料夾(以下稱為專案)裡面的檔案有:</p>
<p><img src="https://i.imgur.com/koCqzQE.jpg" alt="init"></p>
<p>可以看到有許多的資料夾，在下一篇會介紹這些資料夾各自的意義和用途。<br>目前為止已經完成所需的準備了!</p>
<hr>
<h4 id="出發吧-Hexo"><a href="#出發吧-Hexo" class="headerlink" title="出發吧! Hexo"></a>出發吧! Hexo</h4><p><code>&gt;hexo server</code> (server別名 s)<br>上方指令代表啟動伺服器，執行後cmd上顯示</p>
<p><code>&gt;hexo s</code><br><code>INFO  Validating config</code><br><code>INFO  Start processing</code><br><code>INFO  Hexo is running at http://localhost:4000</code><br>在Chrome輸入localhost:4000，就可以看見以下驚奇的畫面!</p>
<p><img src="https://i.imgur.com/FNpSJNt.jpg" alt="localhost"></p>
<p>恭喜你/妳，我們已經正式出發了!<br>接下來的問題是…怎麼在網路上連接到我們的網站呢?</p>
<hr>
<h4 id="屬於每個人的Hexox旅途"><a href="#屬於每個人的Hexox旅途" class="headerlink" title="屬於每個人的Hexox旅途"></a>屬於每個人的Hexox旅途</h4><p>我們會使用Github Pages作為網域去架起Hexo的部落格，若不喜歡或不想要使用Github Pages當然也可以自己購買網域和主機，只是成本就會相對高一點，若未來有機會我們再針對這部分做討論。</p>
<p>首先註冊一個Github的帳號後，在建立Repository頁面輸入Repository的檔案名為:<br><code>/&lt;username&gt;.github.io</code></p>
<p><img src="https://i.imgur.com/TQemfg9.jpg" alt="gitpage"></p>
<p>完成後在cmd安裝發布Deployment的套件<br><code>git install hexo-deployer-git --save</code><br>再來修改**_config.yml組態文件**中修改url欄位與deploy部署的欄位為剛才在Github建立的Repository的名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: http://Mizukikouyou.github.io</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/Mizukikouyou/Mizukikouyou.github.io</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>最後執行以下的指令<br><code>&gt;hexo d</code><br>就可以在你自己的github名稱的github.io裡面看到Git Pages與Hexo成功的搭載上去啦!<br>以上就是今天的Hexo系列文的第一篇!</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>原本預期很快就可以完成第一篇文章，但卻在Github上面摔了一大跤，主要是在使用兩個不同的帳戶去做Deploy，卻一直遇到SSH的問題，測試了好幾種方法，最後卻還是沒辦法解決問題，折衷方案是先用Git Bash強硬推上去，卻遇到更詭異的問題，過幾天再找時間解決它!</p>
<p>我想成功建完Hexo的部落格多多少少會有一點成就感對吧!但，這只是一個開始，再接下來，讓我們一起研究怎麼客製化專屬於自己的Hexo部落格。辛苦看到結尾的你們，還有許多沒有提到，但礙於篇幅就留到下一篇吧!</p>
<p>若有任何缺失或錯誤，再煩請跟我說，謝謝您。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一頁" aria-label="上一頁" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Matsu Chen</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
