<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chenmatsu.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Nothing more than curiosity">
<meta property="og:type" content="website">
<meta property="og:title" content="Matsu">
<meta property="og:url" content="https://chenmatsu.github.io/index.html">
<meta property="og:site_name" content="Matsu">
<meta property="og:description" content="Nothing more than curiosity">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Matsu Chen">
<meta property="article:tag" content="Matsu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chenmatsu.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Matsu</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Matsu</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Nothing more than curiosity</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜尋" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Matsu Chen</p>
  <div class="site-description" itemprop="description">Nothing more than curiosity</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/06/11/Express%E7%B3%BB%E5%88%97-%E5%9F%BA%E6%9C%ACRoute%E5%92%8CMiddleware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/11/Express%E7%B3%BB%E5%88%97-%E5%9F%BA%E6%9C%ACRoute%E5%92%8CMiddleware/" class="post-title-link" itemprop="url">Express系列-基本Route和Middleware</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-06-11 14:44:51" itemprop="dateCreated datePublished" datetime="2021-06-11T14:44:51+08:00">2021-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Node/Express/" itemprop="url" rel="index"><span itemprop="name">Express</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Route和Middleware"><a href="#Route和Middleware" class="headerlink" title="Route和Middleware"></a>Route和Middleware</h3><blockquote>
<p><em>Have no fear of perfection - you’ll never reach it.</em><br><em>― Salvador Dali</em></p>
</blockquote>
<p>昨天第一次介紹Express後端框架，簡單說明如何在Node當中使用以及它的主要功用，另外也提到Middleware的基本概念，今天就來更有效利用Express的超能力吧!</p>
<ul>
<li>Express Middlewares<ul>
<li>Express Routes</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="Express-Middlewares"><a href="#Express-Middlewares" class="headerlink" title="Express Middlewares"></a>Express Middlewares</h4><p>比起中介軟體，我還是習慣直接唸英文，或者想成是橋接器都比中介軟體念起來順手多，在概念上也更容易成形。首先我們建立新的檔案app.js，上一篇文章都有提到，忘記的話可以回上一篇回顧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">// Express處理檔案路徑的核心模組</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">// 內建函數用於提供靜態檔案</span><br><span class="line">app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<p>這裡特別注意的地方是app.use這段程式碼當中，我們透過Express內建函數static()提供靜態檔案，而路徑的設定方式則是使用核心模組path處理，<strong>主要用途在於可以匯入CSS檔案給HTML。</strong></p>
<p>至於<strong>path.join</strong>函數則可以根據作業系統(OS)將檔案串接起來，舉例來說:<br>假設路徑路徑為public -&gt; css -&gt; index.css，則會對應如下<br><code>Windows: \public\css\index.css</code><br><code>Linux: /public/css/index.css</code><br>不一樣的地方在於預設路徑的寫法，現在我們不用去煩惱不同作業系統間的寫法啦!此外，若沒有透過path模組，在Express應用程式當中必須使用絕對路徑。</p>
<p>基本上，我們只需要安裝需要的套件就可以執行功能，省去相當多繁瑣的細節。</p>
<h5 id="Express-Routes"><a href="#Express-Routes" class="headerlink" title="Express Routes"></a>Express Routes</h5><p>最後想特別提及的部分是關於Routes的處理，在Express當中我們一樣是經由Middleware的概念去處理Routes。因為Routes大部分都和網頁URL有關，固然app.use本身就可以拿來處理Routes。</p>
<p>可以根據不同請求方式，改寫Middleware啟動的時機，如下: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.get((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Mioali is passed!&#x27;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Hsinchu is passed!&#x27;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.put((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Taoyuan is passed!&#x27;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.delete((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Taipei is arrived!&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Express Middleware的get, post, put, delete剛好能夠各自對應到http的不同傳輸方式。現在，我們實際上來操作看看Routes。</p>
<p>首先新增routes的資料夾，接著分別建立welcome.js和users.js。程式碼分別如下:<br><code>welcome.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">// 使用Express內建函數來指向切割後的Routes</span><br><span class="line">const router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.sendFile(path.join(__dirname, &#x27;..&#x27;, &#x27;views&#x27;, &#x27;welcome.html&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 匯出檔案的Routes</span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure>
<p><code>users.js</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">const router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(&#x27;/users&#x27;, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.sendFile(path.join(__dirname, &#x27;..&#x27;, &#x27;views&#x27;, &#x27;users.html&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure>
<p>我們將原本寫在app.js處理Routes的Middleware切割到其他的檔案當中，透過Express提供的<strong>Router</strong>函數，我們因此可以指向相同的URL。在GET發出請求後，我們回傳<strong>res.sendFile</strong>()函數，它的功能如同函數名稱一樣，用途在於傳送檔案給使用者，聽起來似乎很奇怪，但有時候我們必須在開發者和使用者角度不斷切換，才有助於理解程式開發。在res.sendFile當中，一樣需要透過path模組去調整我們要存取的路徑，以welcome.js檔案當中，get最後會回傳的檔案會指向類似C:\Users\user\tutorial\views\users.html的檔案路徑。</p>
<p>最後因為我們指向兩個html檔案，自然就需要建立它們，因此先建立views資料夾後再各自建立welcome.html和users.html，內容簡簡單單如下即可:<br><code>welcome.html</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Welcome&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h2&gt;Welcome&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>users.html</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Users&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;Max&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Matsu&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Complex&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>最後實際啟動npm start後，我們就能夠順利看到welcome.html和users.html的畫面囉!</p>
<p><strong>localhost:3000的畫面</strong><br><img src="https://i.imgur.com/14i8Ndu.jpg" alt="welcome"><br><strong>localhost:3000/users的畫面</strong><br><img src="https://i.imgur.com/18IKsOk.jpg" alt="users"></p>
<p>此外若想要套用CSS，只需要將.css檔案，直接寫在HTML檔案各自的head即可。</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>今天再Review過一次Express的一些基本概念和設定，其實完全算不上真正的開工哈哈哈。不過沒關係，一步一腳印，至少今天已經搞懂在Express切割Routes以及如何在HTML檔案當中參照到專案中的CSS檔案，很多隱藏在背後的細節其實需要深思過後才能夠漸漸明瞭運作，若只是單純的套用別人已經寫好的API，我想久而久之會失去自己的思考能力吧! </p>
<p><strong>「物事の本質を考えろう！」と阿部寛がこう言った。真正重要的是思考事物的本質。</strong></p>
<p>繼續苦等東大特訓班2…</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/06/10/Express%E7%B3%BB%E5%88%97-Express%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/10/Express%E7%B3%BB%E5%88%97-Express%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">Express系列-Express介紹與基本概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-06-10 20:08:55" itemprop="dateCreated datePublished" datetime="2021-06-10T20:08:55+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Node/Express/" itemprop="url" rel="index"><span itemprop="name">Express</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Express介紹與基本概念"><a href="#Express介紹與基本概念" class="headerlink" title="Express介紹與基本概念"></a>Express介紹與基本概念</h3><blockquote>
<p><em>I have not failed. I havve just found 10,000 ways that won&#39;t work.</em><br><em>― Thomas A. Edison</em></p>
</blockquote>
<p>Express是伺服器或稱作<strong>後端框架</strong>，最近才認知到Express有別於React、Angular和Vue，說起來也算是天大誤會，好在還沒弄成笑話。今天一起來看看這個框架可以給予我們什麼樣的能力吧!</p>
<ul>
<li>Express介紹<ul>
<li>Express使用</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="Express介紹"><a href="#Express介紹" class="headerlink" title="Express介紹"></a>Express介紹</h4><p>誠如先前所說，Express是伺服器框架其一 ，其餘的類似的框架有Laravel、Flask等等。Express主要的用途在於協助Node去打造Web應用程式的框架和API，大幅減輕開發的負擔。以往在Express開發前，處理API和Web應用程式，需要針對網頁的請求與回應逐一處理，但現在只需要透過Express就可以達到一樣的結果。Express扮演的角色就像是遙控器一樣，開啟電視只需要按下開機關機鍵，若沒有遙控器的話則必須直接按電視螢幕<strong>本身</strong>的開關，但結果上來看是一樣的。</p>
<p>簡言之，Express就是Node處理網站的遙控器!</p>
<h5 id="Express使用"><a href="#Express使用" class="headerlink" title="Express使用"></a>Express使用</h5><p>在使用Express前，我們需要先認識<strong>中介軟體</strong>(Middleware)，中介軟體本身可以想成火車，假設火車從台中北上開往台北，這一路上必須經過苗栗、新竹、桃園、新北幾個城市，而中介軟體則是城市與城市間的溝通方式，並且溝通結果會影響到接下來的行程。</p>
<p>首先在一個資料夾內建立app.js的檔案，基本上檔案名不會影響，不過一般都會命名為app或index兩者其一。建立完成後，切換到資料夾內執行<strong>npm init</strong>設定專案檔。一路按Enter到底將專案檔設為預設即可。大致上會看起來像下方圖片的路徑。</p>
<p><img src="https://i.imgur.com/WyiVozE.jpg" alt="pic1"></p>
<p>接著便於開發我們分別下載<strong>nodemon</strong>套件以及必備的<strong>express</strong>框架，執行以下指令:<br><code>npm install nodemon --save-dev</code><br><code>npm install express --save</code><br>第一個套件的主要功能是用於<strong>自動重啟伺服器</strong>，而不用手動一直重新開啟伺服器，安裝完成後，將<strong>package.json</strong>檔案寫入一個新的腳本檔案，就可以無痛使用nodemon從此不再手殘，如下:</p>
<p><img src="https://i.imgur.com/jAz6Hf7.jpg" alt="script"></p>
<p>接著回到app.js檔案，這裡我們將Express套件引入檔案中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 匯入Express框架套件</span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line"></span><br><span class="line">// 建立Express應用程式 -&gt; 物件具有許多Function和Settings</span><br><span class="line">const app = app.express();</span><br><span class="line"></span><br><span class="line">// 等同於</span><br><span class="line">// const server = http.createServer();</span><br><span class="line">// server.listen(3000);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<p>這段程式碼當中，我們建立Express的應用程式，透過它我們可以使用Express提供的各種Middleware來處理網站，從最後一行app.listen()可以看出Express已經將http核心模組打包起來。<br><code>const server = http.createServer()</code><br><code>server.listen(3000)</code><br>↓<br><code>app.listen(3000)</code></p>
<p>接下來我們將app.js稍微修改一下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Set off at Taichung City!&#x27;);</span><br><span class="line">  // 告訴Middleware可以前往下一個Middleware!</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Mioali is passed!&#x27;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Hsinchu is passed!&#x27;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Taoyuan is passed!&#x27;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;New-Taipei is passed!&#x27;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Taipei is arrived!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<p>透過next()可以調動middleware不斷前往下一個middleware直到發生狀況或是抵達終點。<br>最後<strong>npm start</strong>啟動伺服器後就可以發現我們的中介軟體確實可以一路由台中抵達台北! </p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>今天簡單講解Middleware的概念，其實Middleware可以細分成不同層級的Middleware，就留到下次有機會再來討論。希望不會有人再跟我一樣傻傻分不清楚前後端框架。</p>
<p>最近真的是想到什麼就寫什麼，完全沒有規劃，不過總是想的比較多。這系列文章估計也會寫好幾篇，希望能和React結合在一起XD。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/06/08/Node%E7%B3%BB%E5%88%97-Node%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/08/Node%E7%B3%BB%E5%88%97-Node%E4%BB%8B%E7%B4%B9%E8%88%87%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">Node系列-Node介紹與基本概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-06-08 21:05:08" itemprop="dateCreated datePublished" datetime="2021-06-08T21:05:08+08:00">2021-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Node介紹與基本概念"><a href="#Node介紹與基本概念" class="headerlink" title="Node介紹與基本概念"></a>Node介紹與基本概念</h3><blockquote>
<p><em>Never memorize something that you can look up.</em><br><em>― Albert Einstein</em></p>
</blockquote>
<p>在愛因斯坦的身上，總能夠得到發人省思的一番話，背後一席大道理，目前的我還不太能夠理解。</p>
<p>今天是新系列文想來聊聊關於Node的故事。經過React一番洗禮兼摧殘，終於成為一名React菜鳥，不過可能有人會想連前端都還沒搞專精，就來接觸後端是不是哪裡搞錯? 但是我個人的想法是，唯有學習前端與後端後，才有可能真正專精前端或後端，總不可能後端完全不懂，就串起各種API，就算真的串起來，估計後續也有很多延伸問題，我想至少這是我目前的看法，那，我們趕緊進入正題!</p>
<ul>
<li>Node介紹<ul>
<li>Node核心模組</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="Node介紹"><a href="#Node介紹" class="headerlink" title="Node介紹"></a>Node介紹</h4><p>最近才突然頓悟前後端的區別，以前總覺得自己好像有一定的認知，才發現認知完全是錯誤的。大學期間曾經透過Express和Pug樣板去製作簡單的應用程式，也曾經使用過Flask搭配Pug去處理簡單的網頁，但在學習完React的這陣子後，我才突然想到為何學習前端都沒有聽到Express和Flask，最近發現原來這兩個框架是屬於<strong>後端框架</strong>! 完全跟React八竿子打不著，話是這麼說，但究竟差異在何處?</p>
<p>隨著JS的強勢，2009年源自瑞安·達爾的Node逐漸竄起，甚至可以說是當前最熱門的後端程式語言其一，透過Google開發的V8引擎上而得以運行的伺服器端環境。從此脫離Apache的手掌心，JS更因此從前端語言一躍而出。</p>
<p>Node模組絕大多數以JS撰寫，因此JS本身就能夠自成一套完整的系統，感覺就像是3C產品都用Apple的感覺，一體感所帶來的快感實在美好。簡言之，沒有不用Node的道理！</p>
<h5 id="Node核心模組"><a href="#Node核心模組" class="headerlink" title="Node核心模組"></a>Node核心模組</h5><p>基本上Node的核心模組有http、fs、process等等，數不勝數，不過說這麼多還是直接來實際看看Node的使用方式吧!</p>
<p>面對不同面向會有不同的模組可以使用，不管是要處理HTTP的回應、檔案的讀取寫入、執行緒的控制，甚至是加密演算法都能夠透過Node去實現。</p>
<p>今天我們來透過運行伺服器去理解Node的使用，網路一般的運作方式是透過以下的方式:<br><code>使用者請求 -&gt; 瀏覽器請求 -&gt; 伺服器回應 -&gt; 瀏覽器回應 -&gt; 使用者讀取</code><br>大致上可以上述<strong>粗略</strong>的方式去理解瀏覽網頁的經過，接著我們嘗試透過Node去建立自己的伺服器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 匯入處理http的核心模組</span><br><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line"></span><br><span class="line">// 建立http協議的伺服器，回傳Server物件</span><br><span class="line">const server = http.createServer();</span><br><span class="line"></span><br><span class="line">console.log(server);</span><br><span class="line"></span><br><span class="line">// 伺服器監聽埠(PORT)3000的所有資訊</span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure>

<p>先前我們提到Node有相當多的核心模組，http即是用來處理相關請求、回應的模組。在匯入模組後，建立http協議的伺服器給server，最後監聽server在3000埠口的所有資訊。一種簡單的想法是，server就是在稱作3000路口的監視錄影機，可以處理所有經過路口的車輛與行人。</p>
<p>為了處理經過車輛與行人資訊，我們必須告訴Server車輛與行人要去哪裡，要以何種方式經過路口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line"></span><br><span class="line">// req: 接收的資訊(車輛與行人) res(監視器偵測的回應)</span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  // 擷取req請求的網址(URL)</span><br><span class="line">  const url = req.url;</span><br><span class="line">  // 擷取req請求的方式(GET, POST, PUT, DELETE)</span><br><span class="line">  const method = req.method;</span><br><span class="line"></span><br><span class="line">  console.log(url);</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure>

<p>在Server物件當中有相當龐大的預設資訊，但最主要的則是伺服器接收的訊息與給予的回應，在上方我們拆解出<strong>請求</strong>伺服器的網址，預設的情況下是/，而預設的請求方法則是<strong>GET</strong>。但網頁不僅止於此，我們同樣可以給予伺服器其他的資訊:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line"></span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  // 寫入請求後回應的資訊</span><br><span class="line">  res.write(&#x27;&lt;html&gt;&#x27;);</span><br><span class="line">  res.write(&#x27;&lt;body&gt;&lt;p&gt;Welcome to Node.js&lt;/p&gt;&lt;/body&gt;&#x27;);</span><br><span class="line">  res.write(&#x27;&lt;/html&gt;&#x27;);</span><br><span class="line"></span><br><span class="line">  // 結束接收回應</span><br><span class="line">  res.end();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure>

<p>我們直接在回應的部分寫入HTML格式的程式碼，實際執行後就能夠見到<strong>Welcome to Node.js</strong>的字樣出現在localhost:3000的網頁當中，不僅告訴Server所有資訊的流向與方式，我們同樣可以掌握車輛與行人的數量。這就是最簡單，最基本地使用Node核心模組http的方式。</p>
<p><img src="https://i.imgur.com/ZhIBjlv.jpg" alt="http"></p>
<p>我們再看一個範例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line">// 匯入處理檔案的核心模組</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  // 同步寫入檔案 -&gt; writeFileSync(&#x27;檔案名稱&#x27;, &#x27;檔案內容&#x27;)</span><br><span class="line">  fs.writeFileSync(&#x27;message.txt&#x27;, &#x27;Node is powerful&#x27;);</span><br><span class="line">  res.write(&#x27;&lt;body&gt;&lt;h2&gt;You are writting file!&lt;/h2&gt;&lt;/body&gt;&#x27;);  </span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000);</span><br></pre></td></tr></table></figure>

<p>匯入fs的模組後，我們呼叫fs模組內writeFileSync函數，這個函數主要用於同步處理檔案寫入，不過這邊暫且不討論同步非同步的問題。實際執行後，會在同樣的資料夾下建立message.txt的檔案，裡面確實寫入<strong>Node is powerful</strong>的字樣。</p>
<p><img src="https://i.imgur.com/rOoKSFf.jpg" alt="fs"></p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>我曾用Expres和Flask各自寫些小網頁，結果才發現是一大烏龍，就覺得自己很蠢很好笑。不過今天又重新學習Node，希望我在未來不久內可以了解更多關於後端的運作，特別是API的部分，該找時間寫篇關於API的文章，因為最近用React串接其他公司的API實在慘不忍睹，只能說自己還要多加油。</p>
<p>希望這篇能對剛入門Node的讀者們有點幫助，就讓我們一起成長吧!!</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/06/03/JS%E7%B3%BB%E5%88%97-Closures%E9%96%89%E5%8C%85%E5%85%A5%E9%96%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/03/JS%E7%B3%BB%E5%88%97-Closures%E9%96%89%E5%8C%85%E5%85%A5%E9%96%80/" class="post-title-link" itemprop="url">JS系列-Closures閉包入門</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-06-03 20:02:43" itemprop="dateCreated datePublished" datetime="2021-06-03T20:02:43+08:00">2021-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Closures閉包入門"><a href="#Closures閉包入門" class="headerlink" title="Closures閉包入門"></a>Closures閉包入門</h3><blockquote>
<p><em>Faith is about doing. You are how you act, not just how you believe.</em><br><em>― Mitch Albom, Have a Little Faith: a True Story</em></p>
</blockquote>
<p>最近在用React寫組件時，突然想到閉包(Closures)的使用。具體原因已經有點想不太起來，只記得當天研究閉包一段時間。上一篇文章已經是五月底的事情，時間過的很快，不知不覺也在公司的案子裡埋頭三天多，不過進度很緩慢，心情也是有點忐忑，不確定自己能不能好好完成，也不確定一路走來是對是錯。回歸正題，今天就來探究一下閉包的使用吧!</p>
<ul>
<li>何謂閉包<ul>
<li>基本閉包運用</li>
<li>實際閉包運用</li>
</ul>
</li>
<li>結語</li>
</ul>
<hr>
<h4 id="何謂閉包"><a href="#何謂閉包" class="headerlink" title="何謂閉包"></a>何謂閉包</h4><p>若沒有特別研究，可能會以為閉包是什麼神奇的東西，它很神奇卻也不神奇。在撰寫JS的日子中，我們很常就會運用到閉包的概念。</p>
<p>先來看看MDN關於閉包的敘述:<br><strong>A closure is the combination of a function bundled together with references to its surrounding state.</strong></p>
<p>個人而言，第一次讀到這段話的時候似懂非懂，但唯一可以確信的是，某函數可以參照到它周圍的狀態，至於這個周圍如何判斷就需要透過實際範例來討論，這就好像讀一篇文章，我們必須透過上下文來判斷一句話真正的意圖，程式語言當然也不例外。</p>
<h5 id="基本閉包運用"><a href="#基本閉包運用" class="headerlink" title="基本閉包運用"></a>基本閉包運用</h5><p>首先來看一個簡單的閉包範例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let findNinja = &#x27;ninja&#x27;;</span><br><span class="line"></span><br><span class="line">const trackNinja = () =&gt; &#123;</span><br><span class="line">  if(findNinja === &#x27;ninja&#x27;)&#123;</span><br><span class="line">    console.log(&#x27;We find the ninja!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">trackNinja();</span><br></pre></td></tr></table></figure>
<p>上述是很常見的函數，我們單純宣告一個全域變數以及函數，但若依照<strong>函數可以參照周圍的狀態</strong>，則其實我們正在使用閉包，卻完全沒有發現。不過僅僅是這樣無法理解閉包的奧義，接著看:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const findNinja = () =&gt; &#123;</span><br><span class="line">  let ninja = &#x27;Matsu&#x27;;</span><br><span class="line">  const catchNinja = () =&gt; &#123;</span><br><span class="line">    console.log(ninja);</span><br><span class="line">  &#125;</span><br><span class="line">  return catchNinja;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let realNinja = findNinja();</span><br><span class="line">realNinja();</span><br></pre></td></tr></table></figure>
<p>這次的範例特別的地方在於return catchNinja會先在catchNinja函數執行前先執行，因此若真是如此return過後findNinja就應該找不到Matsu忍者，同樣也無法列印出Ninja的名稱，但是在實際執行後，卻可以找到Matsu忍者，這就是閉包在展現身手的時刻。可是似懂非懂? 我們一步一步解釋，首先當realNinja被指派findNinja函數後參照到catchNinja函數，catchNinja則會建立閉包產生一個泡泡去包住範圍內的變數，而可參照的範圍則是findNinja內的所有變數。我們再看另外一個基本範例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let ninja = &#x27;matsu&#x27;;</span><br><span class="line">let ninja_hide;</span><br><span class="line"></span><br><span class="line">const findMoreNinja = () =&gt; &#123;</span><br><span class="line">  let realNinja = &#x27;Matsu&#x27;;</span><br><span class="line"></span><br><span class="line">  const moreNinja = () =&gt; &#123;</span><br><span class="line">    if(ninja === &#x27;matsu&#x27;) &#123;</span><br><span class="line">      console.log(&#x27;I found ninja matsu!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(realNinja === &#x27;Matsu&#x27;) &#123;</span><br><span class="line">      console.log(realNinja, &#x27;I found real ninja Matsu!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ninja_hide = moreNinja;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findMoreNinja();</span><br><span class="line">ninja_hide();</span><br></pre></td></tr></table></figure>
<p>先後執行findMoreNinja和ninja_hide後，可以發現ninja_hide參照到findMoreNinja裡頭的moreNinja函數，照理說在findMoreNinja結束後，就無法再取得moreNinja的內容，但我們卻能夠取得，換句話說，ninja_hide()本身建立起新的閉包!</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>今天簡簡單單講解閉包的存在，其實閉包可以更加的複雜，只是透過深入理解日常閉包存在的方式，在撰寫JS的過程中便能多留意這個概念，往後在撰寫網站或應用程式時，就更夠理解JS背後運行的方式。學習框架更需要理解這些基本的概念，當開始談起生態圈與優化時，沒有JS基礎的底子，很難去真正釐清程式寫不好的原因在哪裡。</p>
<p>我覺得自己的基礎不是很好，希望能夠透過一篇又一篇的文章，一天一天的進步。今天為了透過Git Pages展示UI給公司的同事了解狀況，研究兩個帳號要如何在本地端切換，數小時過後才終於釐清SSH的使用方式，說真的都能夠再寫成另外一篇文章，很有趣的是，在五月初，剛架好部落格時就遇到同樣的問題，當初是打算要透過另外一個Github帳號去重新實作架設Hexo卻在SSH上面碰壁，時隔一個月，在今天才真的理解SSH的使用方法…，突然在IT邦看見其他大神的文章，才頓悟他們的文章在寫什麼，只能說自己真的還太菜!</p>
<p>希望今天這篇文章能夠對想初步理解閉包的讀者有幫助，謝謝。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chenmatsu.github.io/2021/05/31/React%E7%B3%BB%E5%88%97-%E7%8E%A9%E8%BD%89Typescript%E5%BE%85%E8%BE%A6%E6%B8%85%E5%96%AE-%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Matsu Chen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Matsu">
      <meta itemprop="description" content="Nothing more than curiosity">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Matsu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/31/React%E7%B3%BB%E5%88%97-%E7%8E%A9%E8%BD%89Typescript%E5%BE%85%E8%BE%A6%E6%B8%85%E5%96%AE-%E4%B8%8B/" class="post-title-link" itemprop="url">React系列-玩轉Typescript待辦清單(下)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-05-31 17:37:33" itemprop="dateCreated datePublished" datetime="2021-05-31T17:37:33+08:00">2021-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-08-29 17:36:53" itemprop="dateModified" datetime="2023-08-29T17:36:53+08:00">2023-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming/Javascript/Typescript/" itemprop="url" rel="index"><span itemprop="name">Typescript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="玩轉Typescript"><a href="#玩轉Typescript" class="headerlink" title="玩轉Typescript"></a>玩轉Typescript</h3><blockquote>
<p><em>Work without love is slavery.</em><br><em>― Mother Teresa</em></p>
</blockquote>
<p>沒有愛的工作是奴役，但要怎麼去確認自己的工作是不是有愛?</p>
<p>本篇內容主要源自於上一篇React系列-玩轉Typescript待辦清單(上)。</p>
<p>本來打算將內容都寫在同一篇文章，但還是有點勉強，因此才分為上、下篇，在上一篇文章我們定義完類別和ContextAPI後，這裡我們只需要將它們運用在組件上就大功告成了!</p>
<ul>
<li>實作Todolist</li>
<li>結語</li>
</ul>
<hr>
<h4 id="實作Todolist"><a href="#實作Todolist" class="headerlink" title="實作Todolist"></a>實作Todolist</h4><p>首先處理第一個組件<strong>Todos.tsx</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;Todos.tsx&quot;</span><br><span class="line">import &#123; useContext &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; TodosContext &#125; from &#x27;../store/todos-context&#x27;;</span><br><span class="line">import TodoItem from &#x27;./TodoItem&#x27;;</span><br><span class="line"></span><br><span class="line">const Todos: React.FC = () =&gt; &#123;</span><br><span class="line">  // 使用ContextAPI</span><br><span class="line">  const todosCtx = useContext(TodosContext);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;todosCtx.todos.map((todo) =&gt; (</span><br><span class="line">          &lt;TodoItem</span><br><span class="line">            key=&#123;todo.id&#125;</span><br><span class="line">            name=&#123;todo.name&#125;</span><br><span class="line">            // null告知this不需要參照，todo.id則為第一個參數傳入</span><br><span class="line">            onDeleteTodo=&#123;todosCtx.deleteTodo.bind(null, todo.id)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Todos;</span><br></pre></td></tr></table></figure>

<p>在<strong>Todos</strong>當中使用到<strong>TodoItem</strong>組件，當然就需要再為它建一個組件囉! </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;TodoItem.tsx&quot;</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const TodoItem: React.FC&lt;&#123;name: string; onDeleteTodo: () =&gt; void&#125;&gt; = (props) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;li onClick=&#123;props.onDeleteTodo&#125;&gt;&#123;props.name&#125;&lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default TodoItem;</span><br></pre></td></tr></table></figure>
<p>注意到在React.FC後方透過使用Generic去明確定義變數name和函數onDeleteTodo，因為對於TodoItem組件來說，這兩者都是陌生人。最後，因為我們需要新增項目，自然也就需要新增清單的組件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// In &quot;NewTodo.tsx&quot;</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; useRef, useContext &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; TodosContext &#125; from &#x27;../store/todos-context&#x27;;</span><br><span class="line"></span><br><span class="line">const NewTodo: React.FC = () =&gt; &#123;</span><br><span class="line">  const todosCtx = useContext(TodosContext);</span><br><span class="line"></span><br><span class="line">  // HTMLInputElement代表DOM的元素類別</span><br><span class="line">  const inputRef = useRef&lt;HTMLInputElement&gt;(null);</span><br><span class="line"></span><br><span class="line">  const submitHandler = (event: React.FormEvent) =&gt; &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">    const todoName = inputRef.current!.value;</span><br><span class="line"></span><br><span class="line">    if (todoName.trim().length === 0) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    todosCtx.addTodo(todoName);</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;label htmlFor=&#x27;name&#x27;&gt;Todo Name&lt;/label&gt;</span><br><span class="line">      &lt;input type=&#x27;text&#x27; id=&#x27;name&#x27; ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default NewTodo;</span><br></pre></td></tr></table></figure>
<p>透過使用useRef Hook，可以簡單存取特定欄位的值。唯一需要注意的是HTMLInputElement，在使用Hooks也必須告訴TS相關的型別定義。其餘的都在React系列-useRef概念篇當中有詳細的了解，對於useRef使用有疑問可以參考那篇文章。</p>
<p>最後僅需要將App.tsx做點小修改，就可以成功執行我們的代辦清單囉!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import NewTodo from &#x27;./components/NewTodo&#x27;;</span><br><span class="line">import Todos from &#x27;./components/Todos&#x27;;</span><br><span class="line">import TodosContextProvider from &#x27;./store/todos-context&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const App = () =&gt;  &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;TodosContextProvider &gt;</span><br><span class="line">      &lt;NewTodo/&gt;</span><br><span class="line">      &lt;Todos/&gt;</span><br><span class="line">    &lt;/TodosContextProvider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>稍微添加CSS樣式在其中後，實際執行程式後，大致上會如下圖一樣:<br><img src="https://i.imgur.com/TtSomMd.jpg" alt="pic"></p>
<p>給自己拍拍手! 我想是因為對於TS理解的不夠深，個人覺得在使用起來沒有太大的差別，但確實對於明確的去定義每一個細節要如何使用都非常的清楚明瞭，這應該是最能體會TS的威力的一點! 當然還有很多值得我們去探討的，就交給明天的自己吧!(飄~)</p>
<hr>
<h4 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h4><p>結束五月，不知不覺在這一個月當中有很多成長，不管是學習還是找工作，可以說壓力不少，但卻覺得意外的有趣，看著自己一篇又一篇的文章。有時候都會想為什麼要這麼麻煩，但卻又因為學習的空虛而感到不安，對於我自己來說，忘記以前讀過的書、學會的曲子、寫過的字才是最可怕的，因為那似乎代表自己白活那麼一段時光，一想到此，身體自己就動了起來。</p>
<p>很多時候想的太多，真正需要的只是放手一搏而已，這段路途定然不容易，卻會是朝著理想的路上。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一頁" aria-label="下一頁" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Matsu Chen</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
